<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hiiragi_website</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@tailwindcss/typography@0.5.x/dist/typography.min.css" rel="stylesheet">
    <!-- 本地FontAwesome -->
    <link rel="stylesheet" href="css/fontawesome.min.css">
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <!-- EasyMDE CSS -->
    <link rel="stylesheet" href="https://unpkg.com/easymde/dist/easymde.min.css">
    <!-- Highlight.js CSS (例如 atom-one-dark) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <!-- Your custom CodeMirror theme -->
    <link rel="stylesheet" href="css/purple-cesno.css">  

    <style>
        @font-face {
            font-family: 'Billion Miracles';
            src: url('font/BillionMiracles.woff') format('woff');
        }
        @font-face {
            font-family: '源暎ゴシック';
            src: url('font/GenEiGothicP-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: '源暎ゴシック';
            src: url('font/GenEiGothicP-Light.woff') format('woff');
            font-weight: 300;
            font-style: normal;
        }
        @font-face {
            font-family: '源暎ゴシック';
            src: url('font/GenEiGothicP-SemiLight.woff') format('woff');
            font-weight: 350;
            font-style: normal;
        }
        @font-face {
            font-family: '源暎ゴシック';
            src: url('font/GenEiGothicP-SemiBold.woff') format('woff');
            font-weight: 600;
            font-style: normal;
        }
        
        @font-face {
            font-family: '源暎ゴシック';
            src: url('font/GenEiGothicP-Bold.woff') format('woff');
            font-weight: bold;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Zen Kaku Gothic New';
            src: url('font/ZenKakuGothicNew-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Zen Kaku Gothic New';
            src: url('font/ZenKakuGothicNew-Light.woff') format('woff');
            font-weight: 300;
            font-style: normal;
        }
        @font-face {
            font-family: 'Zen Kaku Gothic New';
            src: url('font/ZenKakuGothicNew-Medium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'Zen Kaku Gothic New';
            src: url('font/ZenKakuGothicNew-Bold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
        }

        /* MODIFIED: Global font and EasyMDE specific fonts */
        body {
            font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif,"Hiragino Kaku Gothic ProN","MS PGothic", "源暎ゴシック", "Zen Kaku Gothic New";
        }
        .EasyMDEContainer .CodeMirror, 
        .EasyMDEContainer .CodeMirror-scroll,
        .EasyMDEContainer .editor-preview, 
        .EasyMDEContainer .editor-preview-side {
            font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif,"Hiragino Kaku Gothic ProN","MS PGothic", "源暎ゴシック", "Zen Kaku Gothic New";
            font-size: 16px; 
            line-height: 1.6;
        }

        /* Styling for PREVIEW AREA code blocks (using Highlight.js) */
        .EasyMDEContainer .editor-preview pre,
        .EasyMDEContainer .editor-preview-side pre {
            background-color: #282c34; /* atom-one-dark background */
            color: #abb2bf;            /* atom-one-dark default text */
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;          /* Horizontal scroll for long lines */
            white-space: pre;          /* Preserve whitespace and newlines */
        }
        .EasyMDEContainer .editor-preview pre code,
        .EasyMDEContainer .editor-preview-side pre code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: transparent; /* Code tag itself should be transparent */
            padding: 0;                /* Reset padding if any from parent */
            display: block;            /* Make code block take full width of pre */
            white-space: inherit;      /* Inherit white-space from pre */
        }
        /* Ensure hljs spans display correctly */
        .EasyMDEContainer .editor-preview pre code .hljs-comment,
        .EasyMDEContainer .editor-preview pre code .hljs-keyword /* etc. for other hljs classes */ {
            /* Styles will come from atom-one-dark.css or your chosen hljs theme */
        }

        /* MODIFIED: Specific heading styles for EasyMDE preview */
        .EasyMDEContainer .editor-preview h1,
        .EasyMDEContainer .editor-preview-side h1 {
            font-size: 2.25em; /* Tailwind's text-4xl is often 2.25rem */
            font-weight: bold;
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            border-bottom: 1px solid #e5e7eb; /* Optional: add a separator like GitHub */
            padding-bottom: 0.3em;
        }
        .EasyMDEContainer .editor-preview h2,
        .EasyMDEContainer .editor-preview-side h2 {
            font-size: 1.875em; /* Tailwind's text-3xl */
            font-weight: bold;
            margin-top: 1.4em;
            margin-bottom: 0.7em;
            border-bottom: 1px solid #e5e7eb; /* Optional */
            padding-bottom: 0.3em;
        }
        .EasyMDEContainer .editor-preview h3,
        .EasyMDEContainer .editor-preview-side h3 {
            font-size: 1.5em; /* Tailwind's text-2xl */
            font-weight: bold;
            margin-top: 1.3em;
            margin-bottom: 0.6em;
        }
        .EasyMDEContainer .editor-preview h4,
        .EasyMDEContainer .editor-preview-side h4 {
            font-size: 1.25em; /* Tailwind's text-xl */
            font-weight: bold;
            margin-top: 1.2em;
            margin-bottom: 0.5em;
        }
        .EasyMDEContainer .editor-preview h5,
        .EasyMDEContainer .editor-preview-side h5 {
            font-size: 1.125em; /* Tailwind's text-lg */
            font-weight: bold;
            margin-top: 1.1em;
            margin-bottom: 0.4em;
        }
        .EasyMDEContainer .editor-preview h6,
        .EasyMDEContainer .editor-preview-side h6 {
            font-size: 1em; /* Tailwind's text-base */
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.3em;
            color: #4b5563; /* Tailwind's gray-600 */
        }

        /* Attempt to contain EasyMDE fullscreen within the modal - VERY EXPERIMENTAL */
        #blog-editor-modal {
            z-index: 1000; /* 比 EasyMDE 全屏时的 z-index 高，如果它用了的话 */
        }
        body.EasyMDE-fullscreen {
            overflow: hidden; /* Prevent body scroll when EasyMDE thinks it's fullscreen */
        }
        /* This targets the modal div directly. It might need a specific ID if this is too general */
        /* #blog-editor-modal > div { */
        /*    max-height: 100vh; */
        /*    overflow-y: auto; */
        /* } */

        /* If EasyMDE wrapper for fullscreen is identifiable and position:fixed */
         /* 目标是让 EasyMDE 的全屏容器表现得像在模态框内部全屏 */
        body.EasyMDE-fullscreen .EasyMDEContainer {
            position: absolute !important; /* 尝试覆盖 EasyMDE 的 fixed 定位 */
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important; /* 填满父容器，即 #blog-editor-modal > div */
            z-index: 500; /* 低于模态框本身的 z-index，但高于普通内容 */
            /* background-color: white; /* 确保有背景，不透明 */
        }

        /* 如果 EasyMDE 使用 .fullScreen 类来实现全屏效果 */
        body.EasyMDE-fullscreen .fullScreen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            /* background-color: white; */
        }
        /* 模态框的内容区域需要允许滚动，并且是 EasyMDE 的相对定位父级 */
        #blog-editor-modal > div { /* 指向 .bg-white.w-full.max-w-screen-lg... */
            position: relative; /* 使内部 absolute 定位的 EasyMDEContainer 相对于它 */
            overflow-y: auto; /* 确保模态框内容本身可以滚动 */
            /* max-height: 90vh; /* 可以限制一下最大高度，避免模态框本身撑满整个屏幕 */
        }


        /* Ensure toolbar icons are visible against any background */
        .EasyMDEContainer .editor-toolbar button .fa {
            color: #333; /* Or a color that stands out */
        }
        .EasyMDEContainer .editor-toolbar button.active .fa {
            color: #007bff; /* Active color */
        }

        :root {
            --primary: #000000;
            --secondary: #333333;
            --accent: #666666;
            --light: #FFFFFF;
            --light-gray: #F5F5F5;
            --medium-gray: #E0E0E0;
        }
        body {
            font-family: 'Zen Kaku Gothic New', sans-serif;
            background-color: var(--light);
            color: var(--primary);
        }
        .title-font {
            font-family: '源暎ゴシック', 'Zen Kaku Gothic New', sans-serif;
            font-size: 30px;
        }
        .english-accent {
            font-family: 'Billion Miracles', cursive;
        }
        .nav-link {
            position: relative;
            transition: all 0.3s ease;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            width: 0;
            height: 1px;
            bottom: -2px;
            left: 0;
            background-color: var(--primary);
            transition: width 0.3s ease;
        }

        .nav-link:hover::after {
            width: 100%;
        }

        .active::after {
            width: 100%;
        }

        .ink-animation {
            height: 210px;
            position: relative;
            overflow: hidden;
            background-color: var(--light);
        }

        .ink-drop {
            position: absolute;
            background-color: var(--primary);
            border-radius: 50%;
            opacity: 0;
            transform: scale(0);
            animation: inkDrop 4s infinite;
        }

        @keyframes inkDrop {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            20% {
                opacity: 0.8;
                transform: scale(1);
            }
            70% {
                opacity: 0.2;
            }
            100% {
                opacity: 0;
                transform: scale(1.5);
            }
        }

        .blog-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid var(--medium-gray);
        }

        .blog-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .label {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 0;
            font-size: 0.75rem;
            margin-right: 4px;
            border: 1px solid var(--primary);
        }

        .pdf-preview {
            border: 1px solid var(--medium-gray);
            padding: 10px;
            transition: transform 0.3s ease;
        }

        .pdf-preview:hover {
            transform: scale(1.02);
        }

        .color-picker {
            appearance: none;
            -webkit-appearance: none;
            width: 25px;
            height: 25px;
            border: 1px solid var(--medium-gray);
            cursor: pointer;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
        }

        .color-picker::-moz-color-swatch {
            border: none;
        }

        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 2rem;
        }

        .pagination-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            margin: 0 4px;
            border: 1px solid var(--medium-gray);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pagination-item:hover {
            background-color: var(--light-gray);
        }

        .pagination-item.active {
            background-color: var(--primary);
            color: var(--light);
            border-color: var(--primary);
        }

        .btn {
            transition: all 0.3s ease;
            border: 1px solid var(--primary);
        }

        .btn-primary {
            background-color: var(--primary);
            color: var(--light);
        }

        .btn-primary:hover {
            background-color: var(--light);
            color: var(--primary);
        }

        .btn-secondary {
            background-color: var(--light);
            color: var(--primary);
        }

        .btn-secondary:hover {
            background-color: var(--primary);
            color: var(--light);
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag {
            padding: 4px 10px;
            background-color: var(--light);
            border: 1px solid var(--medium-gray);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag:hover, .tag.active {
            background-color: var(--primary);
            color: var(--light);
            border-color: var(--primary);
        }

        .calendar-view {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--medium-gray);
            font-size: 0.8rem;
        }

        .calendar-day.has-post {
            background-color: var(--light-gray);
            font-weight: bold;
        }

        .tooltip {
            position: relative;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: var(--primary);
            color: var(--light);
            text-align: center;
            padding: 5px;
            border-radius: 3px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .search-highlight {
            background-color: rgba(0, 0, 0, 0.1);
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--light);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }
        /* Contribution Graph Styles */
        .contribution-cell {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            transition: all 0.2s ease;
        }
        
        .contribution-cell:hover {
            transform: scale(1.2);
        }

        #contribution-graph-activity,
        #contribution-graph-frequency {
            display: grid; 
            grid-template-rows: repeat(7, auto);
            grid-auto-flow: column;
            gap: 1px; 
            margin: 0 auto; /* Basic centering */
            transform: translateX(8px); 
        }
         #contribution-graph-activity .contribution-cell,
         #contribution-graph-frequency .contribution-cell {
            width: 12px;
            height: 12px;
         }

        /* Colors for the first contribution graph (activity - pink theme) */
        #contribution-graph-activity .level-0 { background-color: #ebedf0; }
        #contribution-graph-activity .level-1 { background-color: #ffc0cb; } 
        #contribution-graph-activity .level-2 { background-color: #ff69b4; }
        #contribution-graph-activity .level-3 { background-color: #ff1493; }
        #contribution-graph-activity .level-4 { background-color: #c71585; }

        /* Colors for the second contribution graph (frequency - green theme) */
        #contribution-graph-frequency .level-0 { background-color: #ebedf0; }
        #contribution-graph-frequency .level-1 { background-color: #9be9a8; }
        #contribution-graph-frequency .level-2 { background-color: #40c463; }
        #contribution-graph-frequency .level-3 { background-color: #30a14e; }
        #contribution-graph-frequency .level-4 { background-color: #216e39; }

        #contribution-graph {
            display: grid;
            grid-template-rows: repeat(7, auto);
            grid-auto-flow: column;
            gap: 2px;
            overflow-x: auto;
            padding: 10px;
             /* Add centering */
            margin: 0 auto; /* {{ edit_2 }} */
             /* Add a min-width similar to home page if it's not already set */
             min-width: calc(52 * 12px + 52 * 2px + 12px); /* Adjust min-width for 2px gap */ /* {{ edit_3 }} */
        }
        .responsive-scalable-title {
            font-size: 10vw; /* 字体大小会根据视口宽度的10%进行缩放 */
            white-space: nowrap; /* 防止文字换行 */
            line-height: 1; /* 保持与 text-9xl 类似的行高行为 */
        }
        .responsive-scalable-title2 {
            font-size: 8vw; /* 字体大小会根据视口宽度的10%进行缩放 */
            white-space: nowrap; /* 防止文字换行 */
            line-height: 1; /* 保持与 text-9xl 类似的行高行为 */
        }

        /* CIELLE Page Specific Styles */
        /* 如果您之前对 nav 使用了 .cielle-dark-theme，请统一为 .cielle-dark-theme-active */
        .cielle-dark-theme-active nav {
            background-color: var(--primary) !important; /* 黑底 */
            border-bottom-color: var(--secondary) !important; /* 深色边框 */
        }
        .cielle-dark-theme-active nav .english-accent,
        .cielle-dark-theme-active nav .nav-link {
            color: var(--light) !important; /* 白字 */
        }
        .cielle-dark-theme-active nav .nav-link::after {
            background-color: var(--light) !important; /* 下划线变白 */
        }
        .cielle-dark-theme-active nav #menu-toggle svg {
            stroke: var(--light) !important; /* 移动菜单图标变白 */
        }

        /* CIELLE 水墨画调整 */
        /* 这个规则确保水墨画区域的背景是透明的，这样 #cielle-profile-section 的黑色背景才能显现出来 */
        .cielle-dark-theme-active .ink-animation {
            background-color: transparent !important; 
        }
        /* 将墨滴改为纯白色，以确保在黑色背景下清晰可见 */
        .cielle-dark-theme-active .ink-animation .ink-drop {
            background-color: var(--light) !important; /* 纯白色墨滴 */
            opacity: 0.65; /* 您可以调整不透明度，例如 0.6 到 0.85 之间 */
        }
        /* 如果您想让不同的墨滴有稍微不同的观感，可以单独设置 */
        .cielle-dark-theme-active .ink-animation .ink-drop:nth-child(odd) { /* 例如奇数墨滴 */
            opacity: 0.75;
        }
        /* 确保水墨画中的 "CIELLE" 标题是白色 (尽管您可能已经通过内联样式 text-white 实现) */
         .cielle-dark-theme-active .ink-animation .english-accent {
            color: var(--light) !important; 
        }
        /* CIELLE 页面特定的返回按钮样式 (这个看起来是好的) */
        .cielle-dark-theme-active #back-to-home-from-cielle {
            background-color: var(--secondary);
            color: var(--light);
            border-color: var(--accent);
        }
        .cielle-dark-theme-active #back-to-home-from-cielle:hover {
            background-color: var(--accent);
            border-color: var(--light);
        }
    </style>
</head>

<!----------------------------------------------------------------------------------------------------------------------------->
<!----------------------------------------------------------------------------------------------------------------------------->
<!----------------------------------------------------------------------------------------------------------------------------->
<!-------------------------------------------------------------HTMLMAIN-------------------------------------------------------->
<!----------------------------------------------------------------------------------------------------------------------------->
<!----------------------------------------------------------------------------------------------------------------------------->
<!----------------------------------------------------------------------------------------------------------------------------->

<body>
    <!-- Navigation Bar -->
    <nav class="bg-white border-b border-gray-200 fixed w-full z-10">
        <div class="container mx-auto px-6 py-3 flex justify-between items-center">
            <div>
                <a href="index.html" class="english-accent text-4xl font-bold hover:text-gray-700 transition-colors duration-200">My blog</a>
            </div>
            <div class="hidden md:flex space-x-8">
                <a href="index.html" class="nav-link active">ホーム</a>
                <a href="#blog" class="nav-link">ブログ</a>
                <a href="#document" class="nav-link">ドキュメント</a>
                <a href="#contact" class="nav-link">お問い合わせ</a>
            </div>
            <div class="md:hidden">
                <button id="menu-toggle" class="focus:outline-none">
                    <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div id="mobile-menu" class="hidden md:hidden bg-white px-6 py-4 shadow-inner">
            <a href="#home" class="block py-2">ホーム</a>
            <a href="#blog" class="block py-2">ブログ</a>
            <a href="#document" class="block py-2">ドキュメント</a>
            <a href="#contact" class="block py-2">お問い合わせ</a>
        </div>
    </nav>
    <!-- Main Content -->
    <main>
        <!-- Home Section -->
        <section id="home" class="pt-24">
            <!-- Ink Animation -->
            <div class="ink-animation">
                <div class="ink-drop" style="width: 100px; height: 100px; top: 30%; left: 20%;"></div>
                <div class="ink-drop" style="width: 80px; height: 80px; top: 50%; left: 40%; animation-delay: 1s;"></div>
                <div class="ink-drop" style="width: 120px; height: 120px; top: 20%; left: 60%; animation-delay: 2s;"></div>
                <div class="ink-drop" style="width: 90px; height: 90px; top: 60%; left: 80%; animation-delay: 3s;"></div>
                <div class="english-accent text-black absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 responsive-scalable-title">
                    AI Journey with CIELLE
                </div>
            </div>
            <!-- Profile -->
            <div class="container mx-auto px-6 py-16">
                <div class="flex flex-col md:flex-row items-center">
                    <div class="md:w-1/3 mb-8 md:mb-0">
                        <img src="/data/profile/kyosuke/portrait.jpg" alt="Profile Picture" class="w-48 h-48 mx-auto rounded-full object-cover">
                    </div>
                    <div class="md:w-2/3">
                        <h2 class="title-font text-3xl mb-4">柊杏介(ヒイラギ キョスケ)</h2>
                        <p class="mb-4">SDUFE Artificial Intelligence,Jinan,Shandong</p>
                        <p class="mb-4">人工知能と機械学習に情熱を持つ大学2年生です。データサイエンスと自然言語処理に特に興味があります。このウェブサイトでは、私の学習の旅、プロジェクト、そして考えを共有しています。</p>
                        <div class="flex space-x-4">
                            <a href="#kyosuke-profile" class="btn btn-primary px-4 py-2">プロフィール詳細</a>
                            <a href="#blog" class="btn btn-secondary px-4 py-2">ブログを読む</a>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container mx-auto px-6 py-16 bg-black text-white">
                <div class="flex flex-col md:flex-row items-center">
                    <div class="md:w-1/3 mb-8 md:mb-0">
                        <img src="/data/profile/CIELLE/portrait.jpg" alt="Profile Picture" class="w-48 h-48 mx-auto rounded-full object-cover">
                    </div>
                    <div class="md:w-2/3">
                        <h2 class="title-font text-3xl mb-4">CIELLE</h2>
                        <p class="mb-4">(Under construction)A Self-supervised Multimodal Model.</p>
                        <p class="mb-4">Based on a KAMITSUBAKI's Singer--CIEL
                        </p>
                        <div class="flex space-x-4">
                            <a href="#CIELLE-profile" class="btn btn-secondary px-4 py-2">プロフィール詳細</a>
                            <a href="#CIELLE-profile" class="btn btn-primary px-4 py-2">モテルを試してる</a>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Blog Preview -->
            <div class="bg-gray-50 py-12">
                <div class="container mx-auto px-6">
                    <div class="flex justify-between items-center mb-8">
                        <h2 class="title-font text-2xl">最新のブログ投稿</h2>
                        <a href="#blog" class="text-black hover:underline">すべて見る</a>
                    </div>
                    <div id="latest-posts-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                        <!-- Blog cards will be dynamically inserted here by JavaScript -->
                        <!-- Existing static blog cards below this line (lines 351-390) will be effectively replaced by dynamic content. -->
                        <!-- You can choose to delete the static cards now or let the JS clear them. -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Home Contribution Graphs -->
        <section id="home-contribution-graphs" class="py-12 bg-gray-50">
            <div class="container mx-auto px-6">
                <h2 class="title-font text-2xl mb-8 text-center">私の活動概要</h2>
                <!-- MODIFIED: Removed md:grid-cols-2 to make it always single column (stacking rows) -->
                <div class="grid grid-cols-1 gap-12"> 
                    <div>
                        <h3 class="text-lg font-medium text-gray-700 mb-3 text-center">ブログ活動量 (投稿・更新数)</h3>
                        <div class="bg-white p-4 rounded-md border border-gray-200 overflow-x-auto">
                            <div id="contribution-graph-activity" class="grid grid-rows-7 grid-flow-col gap-1" style="min-width: 700px; "></div>
                            <div class="flex justify-end items-center mt-2 text-sm text-gray-600">
                                <span class="mr-1">少ない</span>
                                <div class="flex items-center">
                                    <div class="contribution-cell level-0"></div>
                                    <div class="contribution-cell level-1"></div>
                                    <div class="contribution-cell level-2"></div>
                                    <div class="contribution-cell level-3"></div>
                                    <div class="contribution-cell level-4"></div>
                                </div>
                                <span class="ml-1">多い</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-gray-700 mb-3 text-center">ブログ編集頻度 (編集回数)</h3>
                        <div class="bg-white p-4 rounded-md border border-gray-200 overflow-x-auto">
                            <div id="contribution-graph-frequency" class="grid grid-rows-7 grid-flow-col gap-1" style="min-width: 700px;"></div>
                             <div class="flex justify-end items-center mt-2 text-sm text-gray-600">
                                <span class="mr-1">少ない</span>
                                <div class="flex items-center">
                                    <div class="contribution-cell level-0"></div>
                                    <div class="contribution-cell level-1"></div>
                                    <div class="contribution-cell level-2"></div>
                                    <div class="contribution-cell level-3"></div>
                                    <div class="contribution-cell level-4"></div>
                                </div>
                                <span class="ml-1">多い</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Blog Section -->
        <section id="blog" class="pt-24 pb-12">
            <div class="container mx-auto px-6">
                <h2 class="title-font text-3xl mb-8 text-center">ブログ</h2>
                <div class="bg-white border border-gray-200 p-6 mb-8">
                    <div class="flex flex-col md:flex-row mb-6">
                        <div class="md:w-2/3 mb-4 md:mb-0">
                            <div class="flex space-x-4">
                                <button id="btn-new-post" class="btn btn-primary px-4 py-2">新規投稿</button>
                            </div>
                        </div>
                        <div class="md:w-1/3">
                            <div class="relative">
                                <input type="text" id="blog-search" placeholder="ブログを検索..." class="w-full px-4 py-2 border border-gray-300 focus:outline-none focus:border-black">
                                <svg class="w-5 h-5 absolute right-3 top-2.5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <!-- Blog View Tabs -->
                    <div class="flex border-b border-gray-200 mb-6">
                        <button class="blog-view-tab px-4 py-2 border-b-2 border-black" data-view="list">リスト表示</button>
                        <button class="blog-view-tab px-4 py-2 border-b-2 border-transparent" data-view="grid">グリッド表示</button>
                        <!-- REMOVED: Calendar View Tab -->
                        <!-- <button class="blog-view-tab px-4 py-2 border-b-2 border-transparent" data-view="calendar">カレンダー表示</button> -->
                    </div>
                    <div class="flex flex-wrap mb-6">
                        <div class="mr-4 mb-2">
                            <label class="mr-2">並び替え:</label>
                            <select id="blog-sort" class="border border-gray-300 px-2 py-1 focus:outline-none focus:border-black">
                                <option value="date-desc">日付 (新しい順)</option>
                                <option value="date-asc">日付 (古い順)</option>
                                <option value="alpha-asc">タイトル (A-Z)</option>
                                <option value="alpha-desc">タイトル (Z-A)</option>
                            </select>
                        </div>
                        <div>
                            <label class="mr-2">ラベル:</label>
                            <select id="blog-label-filter" class="border border-gray-300 px-2 py-1 focus:outline-none focus:border-black">
                                <option value="all">すべて</option>
                                <!-- Options loaded by JS -->
                            </select>
                        </div>
                    </div>
                    <!-- Tag Cloud -->
                    <div class="mb-6">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-lg font-bold">タグ</h3>
                            <div>
                                <button id="add-new-tag-btn" title="新しいタグを追加" class="p-1 text-gray-600 hover:text-black">
                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                                </button>
                                <button id="toggle-delete-tag-btn" title="タグを削除" class="p-1 text-gray-600 hover:text-black">
                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                                </button>
                                <button id="confirm-delete-tags-btn" title="選択したタグを削除" class="hidden p-1 bg-red-500 text-white rounded hover:bg-red-600">削除実行</button>
                                <button id="cancel-delete-tags-btn" title="キャンセル" class="hidden p-1 text-gray-600 hover:text-black">取消</button>
                            </div>
                        </div>
                        <div class="tag-cloud">
                            <!-- Tags will be dynamically loaded here -->
                            <!-- Example static tags (to be replaced by JS) -->
                            <!-- <span class="tag active" data-tag-name="すべて">すべて</span> -->
                            <!-- <span class="tag" data-tag-name="ニューラルネットワーク">ニューラルネットワーク <button class="delete-tag-x hidden">&times;</button></span> -->
                        </div>
                    </div>
                    <!-- List View -->
                    <div id="blog-list-view" class="blog-view-content space-y-6">
                        <!-- Blog list items will be dynamically generated -->
                        <!-- Static items removed -->
                    </div>
                    
                    <!-- Grid View -->
                    <div id="blog-grid-view" class="blog-view-content grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 hidden">
                        <!-- Grid items will be dynamically generated -->
                    </div>
                    <!-- Pagination -->
                    <div class="pagination mt-8">
                        <!-- Pagination will be dynamically generated -->
                    </div>
                </div>
                <!-- Blog Editor Modal -->
                <div id="blog-editor-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
                    <div class="bg-white w-full max-w-screen-lg max-h-screen overflow-y-auto">
                        <div class="p-6">
                            <div class="flex justify-between items-center mb-4">
                                <h3 id="editor-title" class="text-xl font-bold">ブログ投稿を作成</h3>
                                <button id="close-editor" class="text-gray-500 hover:text-gray-700">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </div>
                            <!-- Add an input field to store the identifier of the post being edited -->
                            <!-- This will be the slug for existing posts -->
                            <input type="hidden" id="original-post-identifier"> 
                            <!-- The original-post-title is still useful for display/reference, but slug/ID is better for backend lookups -->
                            <input type="hidden" id="original-post-title"> 

                            <div class="mb-4">
                                <label for="blog-title-editor" class="block text-sm font-medium text-gray-700 mb-1">タイトル</label>
                                <input type="text" id="blog-title-editor" placeholder="タイトル" class="w-full px-4 py-2 border border-gray-300 focus:outline-none focus:border-black">
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                                <div>
                                    <label for="blog-category-editor" class="block text-sm font-medium text-gray-700 mb-1">カテゴリ</label>
                                    <select id="blog-category-editor" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black rounded-md">
                                        <!-- Categories will be loaded here by JS -->
                                        <option value="">読み込み中...</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="blog-tags-editor" class="block text-sm font-medium text-gray-700 mb-1">タグ (カンマ区切り)</label>
                                    <input type="text" id="blog-tags-editor" placeholder="例: AI, Python, Web" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black rounded-md">
                                </div>
                                <div>
                                    <label for="blog-date-editor" class="block text-sm font-medium text-gray-700 mb-1">日付</label>
                                    <input type="date" id="blog-date-editor" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black rounded-md">
                                </div>
                            </div>


                            <div class="mb-4">
                                <label for="blog-content-editor" class="block text-sm font-medium text-gray-700 mb-1">コンテンツ (Markdown)</label>
                                <textarea id="blog-content-editor"></textarea>
                            </div>

                            <div class="flex justify-end">
                                <button id="save-post-button" class="btn btn-primary px-6 py-2">保存</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Post Detail Section -->
        <section id="post-detail-section" class="hidden pt-24 pb-12">
            <div class="container mx-auto px-6">
                <div class="max-w-3xl mx-auto bg-white p-6 md:p-8 shadow-lg rounded-lg border border-gray-200">
                    <button id="back-to-blog-list" class="mb-6 btn btn-secondary px-4 py-2">&laquo; ブログ一覧に戻る</button>
                    <h1 id="post-detail-title" class="text-3xl md:text-4xl font-bold title-font mb-3"></h1>
                    <div class="flex items-center text-sm text-gray-500 mb-1">
                        <span id="post-detail-date" class="mr-4"></span>
                        <span id="post-detail-category" class="label" style="border-color: var(--primary); color: var(--primary);"></span>
                    </div>
                    <div id="post-detail-tags" class="text-sm text-gray-600 mb-6">
                        <!-- Tags will be loaded here -->
                    </div>
                    <div id="post-detail-content-container" class="prose max-w-none prose-lg">
                        <!-- Full post content will be loaded here -->
                    </div>
                </div>
            </div>
        </section>
        <!-- Post Detail Section End -->

        <!-- Kyosuke Profile Detail Section -->
        <section id="kyosuke-profile-section" class="hidden pt-24 pb-12">
            <!-- Ink Animation (copied from home section) -->
            <div class="ink-animation" style="height: 180px;"> <!-- Adjusted height for profile page -->
                <div class="ink-drop" style="width: 100px; height: 100px; top: 30%; left: 20%;"></div>
                <div class="ink-drop" style="width: 80px; height: 80px; top: 50%; left: 40%; animation-delay: 1s;"></div>
                <div class="ink-drop" style="width: 120px; height: 120px; top: 20%; left: 60%; animation-delay: 2s;"></div>
                <div class="ink-drop" style="width: 90px; height: 90px; top: 60%; left: 80%; animation-delay: 3s;"></div>
                <div class="english-accent text-black absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 responsive-scalable-title2">
                    Kyosuke Hiiragi
                </div>
            </div>

            <div class="container mx-auto px-6 py-12">
                <div class="max-w-3xl mx-auto bg-white p-6 md:p-8 shadow-lg rounded-lg border border-gray-200">
                    <div class="text-center mb-8">
                        <img src="/data/profile/kyosuke/portrait.jpg" alt="柊杏介" class="w-32 h-32 md:w-40 md:h-40 mx-auto rounded-full object-cover mb-4 border-2 border-gray-300 p-1">
                        <h1 class="text-2xl md:text-3xl font-bold title-font">柊杏介 (ヒイラギ キョスケ)</h1>
                    </div>

                    <div class="space-y-8">
                        <div>
                            <h2 class="text-xl font-semibold title-font border-b-2 border-gray-300 pb-2 mb-4">基本情報</h2>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm md:text-base">
                                <p><span class="font-medium text-gray-700">性別:</span> <span id="kyosuke-gender">未設定</span></p>
                                <p><span class="font-medium text-gray-700">誕生日:</span> <span id="kyosuke-birthday">未設定</span></p>
                                <p class="sm:col-span-2"><span class="font-medium text-gray-700">趣味:</span> <span id="kyosuke-hobbies">未設定</span></p>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-xl font-semibold title-font border-b-2 border-gray-300 pb-2 mb-4">技術スタック</h2>
                            <div id="kyosuke-tech-stack">
                                <p class="text-gray-500">技術スタック情報を読み込み中...</p>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-xl font-semibold title-font border-b-2 border-gray-300 pb-2 mb-4">学歴</h2>
                            <div id="kyosuke-education" class="prose prose-sm sm:prose max-w-none">
                                <p class="text-gray-500">学歴情報を読み込み中...</p>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-xl font-semibold title-font border-b-2 border-gray-300 pb-2 mb-4">職務経歴</h2>
                            <div id="kyosuke-work-experience" class="prose prose-sm sm:prose max-w-none">
                                <p class="text-gray-500">職務経歴情報を読み込み中...</p>
                            </div>
                        </div>

                        <div>
                            <h2 class="text-xl font-semibold title-font border-b-2 border-gray-300 pb-2 mb-4">自己紹介</h2>
                            <div id="kyosuke-profile-content" class="prose prose-sm sm:prose max-w-none">
                                <p class="text-gray-500">プロフィール情報を読み込み中...</p>
                            </div>
                        </div>
                    </div>
                     <div class="mt-10 text-center">
                        <button id="back-to-home-from-kyosuke" class="btn btn-primary px-6 py-2">ホームページに戻る</button>
                    </div>
                </div>
            </div>
        </section>
        <!-- Kyosuke Profile Detail Section End -->

        <!-- CIELLE Profile Detail Section -->
        <section id="cielle-profile-section" class="hidden pt-24 pb-12 bg-black text-white">
            <!-- Ink Animation (copied from home/kyosuke section, adjusted for dark theme) -->
            <div class="ink-animation" style="height: 180px;">
                <div class="ink-drop" style="width: 100px; height: 100px; top: 30%; left: 20%;"></div>
                <div class="ink-drop" style="width: 80px; height: 80px; top: 50%; left: 40%; animation-delay: 1s;"></div>
                <div class="ink-drop" style="width: 120px; height: 120px; top: 20%; left: 60%; animation-delay: 2s;"></div>
                <div class="ink-drop" style="width: 90px; height: 90px; top: 60%; left: 80%; animation-delay: 3s;"></div>
                <div class="english-accent text-white absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 responsive-scalable-title2">
                    CIELLE
                </div>
            </div>

            <div class="container mx-auto px-6 py-12">
                <div class="flex flex-col lg:flex-row gap-8 lg:gap-12"> 
                    <!-- Left Column (1/3 on larger screens) -->
                    <div class="lg:w-1/3 flex flex-col items-center lg:items-start text-center lg:text-left">
                        <img src="/data/profile/CIELLE/portrait.jpg" alt="CIELLE" class="w-40 h-40 md:w-48 md:h-48 mx-auto lg:mx-0 rounded-full object-cover mb-6 border-2 border-gray-600 p-1">
                        <h2 class="text-3xl font-bold title-font mb-3">CIELLE</h2>
                        <p class="text-md text-gray-300 mb-2 leading-relaxed">(Under construction)</p>
                        <p class="text-md text-gray-300 mb-2 leading-relaxed">A Self-supervised Multimodal Model.</p>
                        <p class="text-sm text-gray-400 italic">Inspired by KAMITSUBAKI's Virtual Singer, CIEL.</p>
                    </div>

                    <!-- Right Column (2/3 on larger screens) -->
                    <div class="lg:w-2/3 space-y-10">
                        <div>
                            <h3 class="text-2xl font-semibold title-font border-b-2 border-gray-700 pb-2 mb-6 text-gray-100">Model Architecture</h3>
                            <div class="max-w-xl mx-auto lg:mx-0"> 
                                <img src="/data/profile/CIELLE/model.jpg" alt="CIELLE Model Architecture" class="w-full h-auto object-contain rounded-lg shadow-xl border border-gray-700">
                            </div>
                            <div class="text-sm text-lg mb-4 mt-8 leading-relaxed"> 
                                <p>これは自己教師あり学習モデルのコンセプトに基づいた、マルチモーダルAI「CIELLE」のアーキテクチャ概要図です。</p>
                                <p>具体的には、音声の波形データ（上部）から音響特徴量（スペクトログラムなど）を抽出します。同時に、音声に対応するテキスト情報はエンコーダー（左下部ブロック）を通じて意味的な表现に変換されます。これらの情報は、中央のTransformerベースの双方向Prior/Posteriorネットワークに入力され、潜在変数 \( z \) を介して相互に関連付けられます。</p>
                                <p>右側のデコーダーブロック（例：HiFi-GANのようなVocoder）は、この潜在変数 \( z \) と、場合によっては追加の音響情報（例：メルスペクトログラムやF0）から元の音声波形を再構築、あるいは新しい音声を生成します。このプロセス全体が、テキスト読み上げ（TTS）、音声変換（VC）、さらには歌声合成（SVS）など、多様な音声相关タスクに応用可能です。</p>
                                <p class="text-sm italic text-gray-500">（注：上記説明は提供された画像に基づいた一般的な解釈であり、実際のモデルの詳細は異なる場合があります。Hubertのような自己教師あり学习の手法は、特に事前学習段階で大量のラベルなしデータから有効な音声表現を獲得するために利用されることがあります。）</p>
                            </div>
                        </div>

                        <div class="pt-8">
                            <h3 class="text-2xl font-semibold title-font border-b-2 border-gray-700 pb-2 mb-6 text-gray-100">Demo</h3>
                            <div style="aspect-ratio: 16 / 9;" class="max-w-2xl mx-auto bg-gray-800 rounded-lg overflow-hidden border border-gray-700 shadow-xl">
                                <video id="cielle-demo-video" controls class="w-full h-full object-contain" preload="metadata">
                                    <source src="/data/profile/CIELLE/preview/video.mkv" type="video/mp4">
                                    お使いのブラウザはビデオタグをサポートしていません。
                                </video>
                            </div>
                        </div>
                    </div>
                </div>
                 <div class="mt-16 text-center">
                    <button id="back-to-home-from-cielle" class="btn btn-secondary px-6 py-2">ホームページに戻る</button> 
                </div>
            </div>
        </section>
        <!-- CIELLE Profile Detail Section End -->

        <!-- Document Section -->
        <section id="document" class="pt-24 pb-12 hidden">
            <!-- Ink Animation for Document Section -->
            <div class="ink-animation" style="height: 180px;">
                <div class="ink-drop" style="width: 100px; height: 100px; top: 30%; left: 20%;"></div>
                <div class="ink-drop" style="width: 80px; height: 80px; top: 50%; left: 40%; animation-delay: 1s;"></div>
                <div class="ink-drop" style="width: 120px; height: 120px; top: 20%; left: 60%; animation-delay: 2s;"></div>
                <div class="ink-drop" style="width: 90px; height: 90px; top: 60%; left: 80%; animation-delay: 3s;"></div>
                <div class="english-accent text-black absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 responsive-scalable-title2">
                    Document
                </div>
            </div>

            <div class="container mx-auto px-6 mt-8"> <!-- Added mt-8 to give some space after the animation -->
                <h2 class="title-font text-3xl mb-8 text-center">ドキュメント</h2>
                <div class="bg-white border border-gray-200 p-6 mb-8 rounded-lg shadow-md">

                    <!-- Document List Area -->
                    <div id="document-list" class="space-y-4">
                        <!-- Document items will be loaded here by JavaScript -->
                        <p class="text-center text-gray-500 py-8">ドキュメントを読み込み中...</p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Document Section End -->


    </main>
    <!-- 联系方式区域 -->
    <section id="contact" class="pt-24 pb-12">
        <div class="container mx-auto px-6">
            <h2 class="title-font text-3xl mb-8 text-center">お問い合わせ</h2>
            <div class="flex flex-col items-center space-y-4">
                <div class="flex items-center space-x-2">
                    <i class="fa fa-phone fa-lg text-black"></i>
                    <span>Tel: 13581576131</span>
                </div>
                <div class="flex items-center space-x-2">
                    <i class="fa fa-envelope fa-lg text-black"></i>
                    <span>E-mail: <a href="mailto:a3416270780@gmail.com" class="underline">a3416270780@gmail.com</a></span>
                </div>
                <div class="flex items-center space-x-2">
                    <i class="fa fa-github fa-lg text-black"></i>
                    <span>Github: <a href="https://github.com/EscoffierZhou" target="_blank" class="underline">github.com/EscoffierZhou</a></span>
                </div>
            </div>
        </div>
    </section>
                                
                                <!-- 页脚部分 -->
                                <footer class="bg-gray-100 py-8">
                                    <div class="container mx-auto px-6 text-center">
                                        <p>&copy; 2023 柊杏介 - AI Journey</p>
                                    </div>
                                </footer>
                                
                                <!-- JavaScript -->
                                <!-- Marked JS (Markdown Parser) -->
                                <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
                                <!-- KaTeX JS and auto-render extension -->
                                <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
                                <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous" onload="window.renderMathInElement = renderMathInElement"></script>
                                <!-- EasyMDE JS -->
                                <script defer src="https://unpkg.com/easymde/dist/easymde.min.js"></script>
                                <!-- Highlight.js Core & Python language -->
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script> 
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/css.min.js"></script>
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
                                <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>

                                <script>
                                    // 移动菜单切换 (这个是独立的，保持不变)
                                    document.getElementById('menu-toggle').addEventListener('click', function() {
                                        document.getElementById('mobile-menu').classList.toggle('hidden');
                                    });

                                    // 这里可以添加其他JavaScript功能 (这个也保持)
                                </script>
                                    <script> // 这是主要的脚本块
                                        // 移动菜单切换 (重复的，可以考虑删除，但暂时保留以防万一)
                                        // document.getElementById('menu-toggle').addEventListener('click', function() {
                                        //     document.getElementById('mobile-menu').classList.toggle('hidden');
                                        // });

                                        const API_BASE_URL = 'http://127.0.0.1:5000/api';

                                        // --- Declare variables for DOM elements in a higher scope ---
                                        let latestPostsGrid, allPostsContent, tagCloudContainer, categoryListContainer;
                                        let homeSection, blogSection, postDetailSection, kyosukeProfileSection, contactSectionInternal; // Renamed to avoid conflict
                                        let postDetailContentContainer, backToBlogListButton;
                                        let kyosukeProfileContent, kyosukeGender, kyosukeBirthday, kyosukeHobbies;
                                        let kyosukeTechStackContainer, kyosukeEducationContainer, kyosukeWorkExperienceContainer;
                                        let blogListView, blogGridView, blogCalendarView; // Added blogGridView, blogCalendarView
                                        let activeBlogView = 'list'; // Default view
                                        let navLinks, mobileNavLinks; // For nav items
                                        let blogSort, searchInput, blogLabelFilter; // Blog filter/sort elements
                                        let newPostBtn, blogEditorModal, closeEditorBtn, savePostBtn; // Editor elements
                                        let blogTitleInput, blogContentInput, blogLabelSelect, blogTagsInput, blogDateInput; // Editor form fields
                                        let contributionGraph; // Contribution graph element
                                        let cielleProfileSection;
                                        let cielleDemoVideo; // 用于控制视频
                                        let backToHomeFromCielleButton; // CIELLE页的返回按钮
                                        let easymde = null; //MODIFIED: For EasyMDE instance
                                        
                                        // Editor Modal Elements
                                        let editorTitle, originalPostTitleInput, blogTitleEditor, blogCategoryEditor, blogTagsEditor, blogDateEditor, blogContentEditor, savePostButton;
                                        // let markdownPreviewArea; // REMOVED: EasyMDE handles preview
                                        let currentEditorSessionId = null; // For temporary file management
                                        let blogLabelFilterElement; // For the filter dropdown in blog section
                                        // let _customMarkedRenderer = null; // We will pass renderer directly to marked.setOptions

                                        // --- NEW: Document Section Elements ---
                                        let documentSection, documentSearchInput, documentTypeFilter, documentSortSelect, documentListContainer;
                                        let documentViewerModal, closeViewerBtn, viewerTitle, viewerContent, viewerContentWrapper, downloadDocumentButton;
                                        // --- END NEW: Document Section Elements ---


                                        // --- Helper Functions ---
                                            function debounce(func, wait) {
                                                let timeout;
                                            return function (...args) {
                                                const context = this;
                                                    clearTimeout(timeout);
                                                timeout = setTimeout(() => func.apply(context, args), wait);
                                            };
                                        }

                                            async function fetchData(endpoint) {
                                                try {
                                                    const response = await fetch(`${API_BASE_URL}${endpoint}`);
                                                    if (!response.ok) {
                                                        throw new Error(`HTTP error! status: ${response.status} for ${endpoint}`);
                                                    }
                                                    return await response.json();
                                                } catch (error) {
                                                    console.error(`Could not fetch ${endpoint}:`, error);
                                                    return null;
                                                }
                                            }

                                            // --- Rendering Functions ---
                                            function renderPostCard(post, showAdminControls = true) {
                                                const getProp = (obj, path, defaultValue = '') => path.split('.').reduce((res, key) => res && res[key] !== undefined && res[key] !== null ? res[key] : defaultValue, obj);
                                                const title = getProp(post, 'title', '無題の投稿');
                                                // const date = getProp(post, 'date', '日付不明');
                                                const category = getProp(post, 'category', '未分類');
                                            const slug = getProp(post, 'slug', title);
                                            const summary = getProp(post, 'summary', '記事を読むにはクリックしてください...');
                                                // MODIFIED: Use the preview_image_url from the post data
                                                const imageUrl = getProp(post, 'preview_image_url', ''); 
                                                const safeTitle = encodeURIComponent(title); 

                                                // Admin controls HTML part
                                                const adminControlsHTML = showAdminControls ? `
                                                    <div class="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex space-x-1 bg-white p-1 rounded shadow">
                                                        <button class="edit-post-btn p-1 text-gray-600 hover:text-black" data-post-title="${safeTitle}" title="編集">
                                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd"></path></svg>
                                                        </button>
                                                        <!-- MODIFIED: Add data-post-id attribute to the delete button -->
                                                        <button class="delete-post-btn p-1 text-gray-600 hover:text-red-600" data-post-title="${safeTitle}" data-post-id="${getProp(post, 'id', '')}" title="削除">
                                                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                                                        </button>
                                                    </div>` : '';

                                                return `
                                                <div class="blog-card bg-white overflow-hidden relative group">
                                                ${imageUrl ? `<img src="${API_BASE_URL.replace('/api', '')}${imageUrl}" alt="${title}" class="w-full h-40 object-cover">` : `
                                                    <div class="h-40 bg-gray-100 flex items-center justify-center">
                                                        <svg class="w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                                                </div>`}
                                                    <div class="p-6">
                                                        <div class="flex justify-between items-center mb-2">
                                                            <span class="text-sm text-gray-500">${date}</span>
                                                            <span class="label" style="border-color: var(--primary); color: var(--primary);">${category}</span>
                                                        </div>
                                                        <h3 class="font-bold text-xl mb-2">${title}</h3>
                                                        <p class="text-gray-700 mb-4 text-sm">${summary}</p>
                                                        <a href="#blog/${encodeURIComponent(slug)}" class="text-black hover:underline post-detail-link" data-post-slug="${encodeURIComponent(slug)}">続きを読む</a>
                                                    </div>
                                                    ${adminControlsHTML} 
                                            </div>`;
                                            }
                                            async function loadLatestPosts() {
                                                if (!latestPostsGrid) return;
                                            const posts = await fetchData('/latest-statistical-posts'); 
                                                if (posts && posts.length > 0) {
                                                    // MODIFIED: Pass false to hide admin controls for latest posts
                                                    latestPostsGrid.innerHTML = posts.map(post => renderPostCard(post, false)).join('');
                                                } else {
                                                    latestPostsGrid.innerHTML = '<p>最新の投稿はありません。</p>';
                                                }
                                            }

                                        async function loadAllBlogPosts(searchTerm = '', selectedTags = [], selectedCategory = '', page = 1) {
                                            console.log("DEBUG: loadAllBlogPosts called with:", { searchTerm, selectedTags, selectedCategory, page });
                                            // Determine the correct container based on the active view
                                            let currentViewContainer;
                                            if (activeBlogView === 'list' && blogListView) {
                                                currentViewContainer = blogListView;
                                            } else if (activeBlogView === 'grid' && blogGridView) {
                                                currentViewContainer = blogGridView;
                                            } else {
                                                console.warn(`loadAllBlogPosts: Active view container for '${activeBlogView}' not found or view not supported for direct post rendering.`);
                                                if(document.getElementById('all-posts-content')) document.getElementById('all-posts-content').innerHTML = '<p>表示するビューコンテナが見つかりません。</p>';
                                                return;
                                            }

                                            if (!currentViewContainer) {
                                                console.error(`Container for active view '${activeBlogView}' is not initialized.`);
                                                return;
                                            }

                                            const allPosts = await fetchData('/posts'); // Fetches all posts metadata
                                            if (allPosts) { // Check if allPosts is not null
                                                // 1. 先进行过滤 (包括搜索、标签和分类)
                                                let filteredPosts = allPosts.filter(post => {
                                                    const matchesSearch = searchTerm === '' || post.title.toLowerCase().includes(searchTerm.toLowerCase()) || (post.summary && post.summary.toLowerCase().includes(searchTerm.toLowerCase()));
                                                    // Ensure post.tags is an array before calling .includes()
                                                    const postTagsArray = Array.isArray(post.tags) ? post.tags : [];
                                                    const matchesTags = selectedTags.length === 0 || selectedTags.every(tag => postTagsArray.includes(tag));
                                                    const matchesCategory = selectedCategory === '' || post.category === selectedCategory;
                                                    console.log(`DEBUG Filter: Post "${post.title}" - Search:${matchesSearch}, Tags:${matchesTags}, Category:${matchesCategory}`); // Add per post filter check
                                                    return matchesSearch && matchesTags && matchesCategory;
                                                });
                                                console.log("DEBUG: Filtered posts count:", filteredPosts.length);
                                                // 2. 然后对过滤后的文章进行排序
                                                const sortOrder = blogSort ? blogSort.value : 'date-desc';
                                                // 注意：这里要对 filteredPosts 进行排序
                                                filteredPosts.sort((a, b) => {
                                                    let dateA, dateB;
                                                    const parseRobustDate = (dateStr) => {
                                                        if (!dateStr || typeof dateStr !== 'string') {
                                                            return new Date(0); 
                                                        }
                                                        const matchJa = dateStr.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/);
                                                        if (matchJa) {
                                                            return new Date(parseInt(matchJa[1]), parseInt(matchJa[2]) - 1, parseInt(matchJa[3]));
                                                        }
                                                        const parsedDate = new Date(dateStr);
                                                        if (!isNaN(parsedDate.getTime())) {
                                                            return parsedDate;
                                                        }
                                                        return new Date(0); 
                                                    };

                                                    try {
                                                        dateA = parseRobustDate(a.date);
                                                        dateB = parseRobustDate(b.date);
                                                    } catch (e) {
                                                        console.warn("Date parsing error during sort:", e, "for dates:", a.date, b.date);
                                                        return 0; 
                                                    }

                                                    if (sortOrder === 'date-desc') return dateB - dateA;
                                                    if (sortOrder === 'date-asc') return dateA - dateB;
                                                    if (sortOrder === 'alpha-asc') return String(a.title).localeCompare(String(b.title), 'ja'); 
                                                    if (sortOrder === 'alpha-desc') return String(b.title).localeCompare(String(a.title), 'ja'); 
                                                    return 0;
                                                });
                                                
                                                // 现在 filteredPosts 已经是先过滤后排序的结果
                                                const postsPerPage = (activeBlogView === 'grid') ? 9 : 6; 
                                                    const totalPages = Math.ceil(filteredPosts.length / postsPerPage);
                                                    const startIndex = (page - 1) * postsPerPage;
                                                const paginatedPosts = filteredPosts.slice(startIndex, startIndex + postsPerPage); // 对 filteredPosts 进行分页

                                                    if (paginatedPosts.length > 0) {
                                                    if (activeBlogView === 'list') {
                                                        currentViewContainer.innerHTML = paginatedPosts.map(post => renderPostListItem(post)).join('');
                                                    } else if (activeBlogView === 'grid') {
                                                        currentViewContainer.innerHTML = paginatedPosts.map(post => renderPostCard(post)).join(''); 
                                                    }
                                                    renderPagination(page, totalPages, searchTerm, selectedTags, selectedCategory);
                                                    } else {
                                                    currentViewContainer.innerHTML = '<p class="text-center py-8 text-gray-500">選択された条件に一致する投稿はありません。</p>';
                                                    const paginationDiv = document.querySelector('.pagination'); 
                                                    if(paginationDiv) paginationDiv.innerHTML = '';
                                                    }
                                                } else {
                                                currentViewContainer.innerHTML = '<p class="text-center py-8 text-gray-500">投稿はありません。</p>';
                                                const paginationDiv = document.querySelector('.pagination'); 
                                                if(paginationDiv) paginationDiv.innerHTML = '';
                                            }
                                        }

                                        // New function to render items specifically for the list view
                                        function renderPostListItem(post) {
                                            const getProp = (obj, path, defaultValue = '') => path.split('.').reduce((res, key) => res && res[key] !== undefined && res[key] !== null ? res[key] : defaultValue, obj);
                                            const title = getProp(post, 'title', '無題の投稿');
                                            const date = getProp(post, 'date', '日付不明');
                                            const category = getProp(post, 'category', '未分類');
                                            const slug = getProp(post, 'slug', title);
                                            const summary = getProp(post, 'summary', 'この記事を読むにはクリックしてください。'); // Assuming summary comes from backend
                                            const tags = Array.isArray(post.tags) ? post.tags : [];
                                            const safeTitle = encodeURIComponent(title);

                                            // Determine category color (optional, if you have a mapping)
                                            // const categoryColor = categoryColors[category.toLowerCase()] || 'var(--primary)';

                                            return `
                                                <div class="blog-item border-b border-gray-200 pb-6 mb-6 group relative">
                                                    <div class="flex justify-between items-start mb-2">
                                                        <h3 class="font-bold text-xl hover:text-gray-700 transition-colors">
                                                            <a href="#blog/${encodeURIComponent(slug)}" class="post-detail-link" data-post-slug="${encodeURIComponent(slug)}">${title}</a>
                                                        </h3>
                                                        <div class="flex items-center space-x-2">
                                                            <span class="label" style="border-color: var(--primary); color: var(--primary);">${category}</span>
                                                            <div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex space-x-1 bg-white p-1 rounded shadow absolute top-0 right-0 mt-1 mr-1">
                                                                <button class="edit-post-btn p-1 text-gray-600 hover:text-black" data-post-title="${safeTitle}" title="編集">
                                                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd"></path></svg>
                                                                </button>
                                                                <!-- MODIFIED: Add data-post-id attribute to the delete button -->
                                                                <button class="delete-post-btn p-1 text-gray-600 hover:text-red-600" data-post-title="${safeTitle}" data-post-id="${getProp(post, 'id', '')}" title="削除">
                                                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                                                                </button>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <p class="text-sm text-gray-500 mb-2">${date}</p>
                                                    <p class="text-gray-700 mb-2 text-sm leading-relaxed">${summary}</p>
                                                    ${tags.length > 0 ? `
                                                        <div class="flex items-center space-x-2 mb-2">
                                                            <span class="text-xs text-gray-500">タグ:</span>
                                                            ${tags.map(tag => `<span class="text-xs bg-gray-100 px-2 py-1 rounded">${tag}</span>`).join('')}
                                                        </div>
                                                    ` : ''}
                                                    <a href="#blog/${encodeURIComponent(slug)}" class="text-black hover:underline post-detail-link" data-post-slug="${encodeURIComponent(slug)}">続きを読む</a>
                                                </div>
                                            `;
                                        }

                                        function renderPagination(currentPage, totalPages, searchTerm, selectedTags, selectedCategory) {
                                                const paginationContainer = document.querySelector('.pagination'); // Directly select the existing pagination
                                                if (!paginationContainer) return;
                                                let paginationHTML = '<div class="pagination">';
                                            if (currentPage > 1) paginationHTML += `<button class="pagination-item" data-page="${currentPage - 1}">&laquo;</button>`;
                                                const maxVisiblePages = 5;
                                                let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
                                                let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
                                            if (endPage - startPage + 1 < maxVisiblePages) startPage = Math.max(1, endPage - maxVisiblePages + 1);
                                            for (let i = startPage; i <= endPage; i++) paginationHTML += `<button class="pagination-item ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                                            if (currentPage < totalPages) paginationHTML += `<button class="pagination-item" data-page="${currentPage + 1}">&raquo;</button>`;
                                                paginationHTML += '</div>';
                                                paginationContainer.innerHTML = paginationHTML;
                                                paginationContainer.querySelectorAll('.pagination-item').forEach(item => {
                                                    item.addEventListener('click', function () {
                                                    loadAllBlogPosts(searchTerm, selectedTags, selectedCategory, parseInt(this.dataset.page));
                                                    });
                                                });
                                            }
                                        async function loadTags() {
                                            if (!tagCloudContainer) {
                                                console.error("Tag cloud container not found.");
                                                return;
                                            }
                                            const tags = await fetchData('/tags'); // Fetches array of tag strings
                                            if (tags) {
                                                let tagsHTML = '<span class="tag active" data-tag-name="すべて">すべて</span>'; // "All" tag
                                                tags.forEach(tag => {
                                                    if (tag.trim() !== "") { // Ensure tag is not empty
                                                        tagsHTML += `
                                                            <span class="tag" data-tag-name="${tag}">
                                                                ${tag}
                                                                <button class="delete-tag-x hidden text-red-500 hover:text-red-700 ml-1 font-bold" data-tag-to-delete="${tag}">&times;</button>
                                                            </span>`;
                                                    }
                                                });
                                                tagCloudContainer.innerHTML = tagsHTML;

                                                // Add event listeners to new tag elements
                                                tagCloudContainer.querySelectorAll('.tag').forEach(tagEl => {
                                                    tagEl.addEventListener('click', function(event) {
                                                        if (event.target.classList.contains('delete-tag-x')) {
                                                            // This click is handled by the delete-tag-x listener below
                                                            return;
                                                        }

                                                        const tagName = this.dataset.tagName;
                                                        if (tagName === 'すべて') {
                                                            tagCloudContainer.querySelectorAll('.tag.active').forEach(activeEl => activeEl.classList.remove('active'));
                                                            this.classList.add('active');
                                                        } else {
                                                            // Remove 'active' from 'すべて' if another tag is clicked
                                                            const allTag = tagCloudContainer.querySelector('.tag[data-tag-name="すべて"]');
                                                            if (allTag) allTag.classList.remove('active');
                                                            this.classList.toggle('active');
                                                        }
                                                        // After toggling, check if any specific tag is active. If not, make 'すべて' active.
                                                        const anyActiveSpecificTag = Array.from(tagCloudContainer.querySelectorAll('.tag.active')).some(t => t.dataset.tagName !== 'すべて');
                                                        if (!anyActiveSpecificTag && tagCloudContainer.querySelector('.tag[data-tag-name="すべて"]')) {
                                                             tagCloudContainer.querySelector('.tag[data-tag-name="すべて"]').classList.add('active');
                                                        }


                                                        const activeTagNames = Array.from(tagCloudContainer.querySelectorAll('.tag.active'))
                                                                                .map(activeEl => activeEl.dataset.tagName)
                                                                                .filter(name => name !== 'すべて'); // Exclude "すべて" from filter values
                                                        
                                                        loadAllBlogPosts(
                                                            searchInput.value,
                                                            activeTagNames,
                                                            blogLabelFilter.value === 'all' ? '' : blogLabelFilter.value
                                                        );
                                                    });
                                                });

                                                // Listener for the small 'x' on tags (for deletion mode)
                                                tagCloudContainer.querySelectorAll('.delete-tag-x').forEach(delXBtn => {
                                                    delXBtn.addEventListener('click', async function(event) {
                                                        event.stopPropagation(); // Prevent tag click
                                                        const tagToDelete = this.dataset.tagToDelete;
                                                        if (confirm(`タグ「${tagToDelete}」を完全に削除してもよろしいですか？関連する投稿からもこのタグは削除されます。`)) {
                                                            await deleteTagFromServer(tagToDelete);
                                                        }
                                                    });
                                                });

                                            } else {
                                                tagCloudContainer.innerHTML = '<p>タグの読み込みに失敗しました。</p>';
                                            }
                                        }
                                        async function loadCategories() { /* ... */ } // This function seems to be unused, consider removing if not planned.
                                        async function loadPostDetail(postSlug) { /* ... */ }
                                        async function loadKyosukeProfileData() {
                                            if (!kyosukeProfileSection) {
                                                console.error("kyosukeProfileSection is not initialized in loadKyosukeProfileData");
                                                return;
                                            }

                                            // 清空技术栈容器，但不显示"加载中"给技术栈
                                            if(kyosukeTechStackContainer) kyosukeTechStackContainer.innerHTML = ''; 

                                            // 其他部分的加载状态可以保留
                                            if(kyosukeProfileContent) kyosukeProfileContent.innerHTML = '<p class="text-gray-500">プロフィール情報を読み込み中...</p>';
                                            if(kyosukeEducationContainer) kyosukeEducationContainer.innerHTML = '<p class="text-gray-500">学歴情報を読み込み中...</p>';
                                            if(kyosukeWorkExperienceContainer) kyosukeWorkExperienceContainer.innerHTML = '<p class="text-gray-500">職務経歴情報を読み込み中...</p>';
                                            if(kyosukeGender) kyosukeGender.textContent = '読み込み中...';
                                            if(kyosukeBirthday) kyosukeBirthday.textContent = '読み込み中...';
                                            if(kyosukeHobbies) kyosukeHobbies.textContent = '読み込み中...';

                                            const data = await fetchData('/profile/kyosuke'); 

                                            if (data) {
                                                if (kyosukeGender) kyosukeGender.textContent = data.gender || '未設定';
                                                if (kyosukeBirthday) kyosukeBirthday.textContent = data.birthday || '未設定';
                                                if (kyosukeHobbies) kyosukeHobbies.textContent = data.hobbies || '未設定';
                                                
                                                if (kyosukeProfileContent) {
                                                    kyosukeProfileContent.innerHTML = data.bio_html || '<p>自己紹介はありません。</p>';
                                                }

                                                // 直接渲染技术栈，如果数据存在
                                                if (kyosukeTechStackContainer && data.skills && data.skills.length > 0) {
                                                    renderKyosukeTechStack(data.skills);
                                                } else if (kyosukeTechStackContainer) {
                                                    // 如果没有技能数据，可以显示提示信息
                                                    kyosukeTechStackContainer.innerHTML = '<p>技術スタック情報はありません。</p>';
                                                }

                                                if (kyosukeEducationContainer && data.education && data.education.length > 0) {
                                                    kyosukeEducationContainer.innerHTML = data.education.map(edu => `<div class="mb-3"><h4 class="font-semibold">${edu.institution} (${edu.period})</h4><p class="text-sm text-gray-600">${edu.details}</p></div>`).join('');
                                                } else if (kyosukeEducationContainer) {
                                                    kyosukeEducationContainer.innerHTML = '<p>学歴情報はありません。</p>';
                                                }

                                                if (kyosukeWorkExperienceContainer && data.workExperience && data.workExperience.length > 0) {
                                                    kyosukeWorkExperienceContainer.innerHTML = data.workExperience.map(exp => {
                                                        if (!exp.company && !exp.period && exp.role) return `<p>${exp.role}</p>`;
                                                        if (!exp.company && !exp.period && !exp.role && !exp.details) return '';
                                                        return `<div class="mb-3"><h4 class="font-semibold">${exp.role} ${exp.company ? `at ${exp.company}` : ''} ${exp.period ? `(${exp.period})` : ''}</h4><p class="text-sm text-gray-600">${exp.details || ''}</p></div>`;
                                                    }).join('');
                                                    if (kyosukeWorkExperienceContainer.innerHTML.trim() === '') kyosukeWorkExperienceContainer.innerHTML = '<p>職務経歴情報はありません。</p>';
                                                } else if (kyosukeWorkExperienceContainer) {
                                                    kyosukeWorkExperienceContainer.innerHTML = '<p>職務経歴情報はありません。</p>';
                                                }
                                                } else {
                                                if(kyosukeProfileContent) kyosukeProfileContent.innerHTML = '<p class="text-red-500">プロフィールの読み込みに失敗しました。</p>';
                                                if(kyosukeTechStackContainer) kyosukeTechStackContainer.innerHTML = '<p class="text-red-500">技術スタックの読み込みに失敗しました。</p>';
                                                // Set other fields to error or default as well
                                                }
                                            }
                                        function renderKyosukeTechStack(skills) { /* ... */ }
                                        function setupContributionGraph() {
                                            const graphContainer = document.getElementById('contribution-graph');
                                            const legendContainer = document.getElementById('contribution-graph-legend');
                                            
                                            if (!graphContainer) {
                                                console.error('贡献图容器未找到。');
                                                return;
                                            }
                                            
                                            if (!legendContainer) {
                                                console.error('贡献图图例容器未找到。');
                                                // 图例不是必须的，所以继续执行
                                            }
                                            
                                            // 清空容器
                                            graphContainer.innerHTML = '';
                                            
                                            // 模拟贡献数据（如果没有真实数据）
                                            // 在实际应用中，您应该从服务器获取这些数据
                                            const generateMockData = () => {
                                                const data = [];
                                                // 生成一年的数据（7天 x 52周 = 364天，加上1天 = 365天）
                                                for (let i = 0; i < 365; i++) {
                                                    // 随机生成0-4的贡献等级
                                                    const level = Math.floor(Math.random() * 5);
                                                    // 随机生成0-10的贡献数量
                                                    const count = level === 0 ? 0 : Math.floor(Math.random() * 10 * level);
                                                    data.push(`${level},${count}`);
                                                }
                                                return data;
                                            };
                                            
                                            // 尝试获取贡献数据，如果失败则使用模拟数据
                                            fetch('data/contribution.txt')
                                                .then(response => {
                                                    if (!response.ok) {
                                                        throw new Error('无法获取贡献数据');
                                                    }
                                                    return response.text();
                                                })
                                                .then(data => {
                                                    const lines = data.trim().split('\n');
                                                    createContributionGraph(lines);
                                                })
                                                .catch(error => {
                                                    console.warn('获取贡献数据失败，使用模拟数据:', error);
                                                    const mockData = generateMockData();
                                                });
                                            
                                        }

                                            // --- View Management ---
                                            function showView(viewName) {
                                                console.log(`[showView] Called for view: ${viewName}`); // Log entry
                                            // 首先，默认移除 CIELLE 的特殊主题类，以防它残留
                                            document.body.classList.remove('cielle-dark-theme-active');
                                            // 同时也移除之前用于导航栏的 cielle-dark-theme，如果还在使用的话
                                            document.body.classList.remove('cielle-dark-theme');


                                            if (homeSection) homeSection.classList.add('hidden');
                                            if (blogSection) blogSection.classList.add('hidden');
                                            if (postDetailSection) postDetailSection.classList.add('hidden');
                                            if (kyosukeProfileSection) kyosukeProfileSection.classList.add('hidden');
                                            if (cielleProfileSection) cielleProfileSection.classList.add('hidden');
                                            if (contactSectionInternal) contactSectionInternal.classList.add('hidden');
                                            
                                            if (documentSection) {
                                                console.log(`[showView] Hiding documentSection as part of reset. Current classes: ${documentSection.className}`);
                                                documentSection.classList.add('hidden');
                                            } else {
                                                console.warn("[showView] documentSection element not found when trying to hide during reset.");
                                            }

                                            // MODIFIED: Explicitly hide contribution graphs section initially
                                            const homeContributionGraphsSection = document.getElementById('home-contribution-graphs');
                                            if (homeContributionGraphsSection) {
                                                homeContributionGraphsSection.classList.add('hidden');
                                            }


                                            if (navLinks) navLinks.forEach(link => link.classList.remove('active'));
                                            if (mobileNavLinks) mobileNavLinks.forEach(link => link.classList.remove('active'));

                                                let activeNavLink;

                                                if (viewName === 'home') {
                                                if (homeSection) homeSection.classList.remove('hidden');
                                                // MODIFIED: Show contribution graphs section ONLY on home page
                                                if (homeContributionGraphsSection) {
                                                    homeContributionGraphsSection.classList.remove('hidden');
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="index.html"], .nav-link[href="#home"]`);
                                                } else if (viewName === 'blog') {
                                                if (blogSection) blogSection.classList.remove('hidden');
                                                    activeNavLink = document.querySelector(`.nav-link[href="#blog"]`);
                                                } else if (viewName === 'post-detail') {
                                                if (postDetailSection) postDetailSection.classList.remove('hidden');
                                                    activeNavLink = document.querySelector(`.nav-link[href="#blog"]`);
                                            } else if (viewName === 'kyosuke-profile') {
                                                if (kyosukeProfileSection) {
                                                    kyosukeProfileSection.classList.remove('hidden');
                                                    loadKyosukeProfileData();
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="index.html"], .nav-link[href="#home"]`);
                                            } else if (viewName === 'cielle-profile') { // 新增CIELLE路由
                                                if (cielleProfileSection) {
                                                    cielleProfileSection.classList.remove('hidden');
                                                    document.body.classList.add('cielle-dark-theme-active'); // **重要：添加主题类**
                                                    if (cielleDemoVideo) {
                                                        cielleDemoVideo.currentTime = 0;
                                                        cielleDemoVideo.pause();
                                                    }
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="index.html"], .nav-link[href="#home"]`);
                                                } else if (viewName === 'contact') {
                                                if (contactSectionInternal) contactSectionInternal.classList.remove('hidden');
                                                    activeNavLink = document.querySelector(`.nav-link[href="#contact"]`);
                                            // --- NEW: Handle document view ---
                                            } else if (viewName === 'document') {
                                                if (documentSection) {
                                                    console.log(`[showView] Attempting to show documentSection. Current classes before remove: ${documentSection.className}`);
                                                    documentSection.classList.remove('hidden');
                                                    console.log(`[showView] documentSection classes after remove: ${documentSection.className}`);
                                                    // Check visibility
                                                    const styles = window.getComputedStyle(documentSection);
                                                    console.log(`[showView] documentSection computed display style: ${styles.display}, opacity: ${styles.opacity}, visibility: ${styles.visibility}`);
                                                    loadDocuments(); // Load documents when the section is shown
                                                } else {
                                                     console.error("[showView] documentSection element not found when trying to show 'document' view.");
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="#document"]`);
                                            // --- END NEW ---
                                                } else if (viewName === 'kyosuke-profile') {
                                                if (kyosukeProfileSection) {
                                                    kyosukeProfileSection.classList.remove('hidden');
                                                    loadKyosukeProfileData();
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="index.html"], .nav-link[href="#home"]`);
                                            } else if (viewName === 'cielle-profile') { // 新增CIELLE路由
                                                if (cielleProfileSection) {
                                                    cielleProfileSection.classList.remove('hidden');
                                                    document.body.classList.add('cielle-dark-theme-active'); // **重要：添加主题类**
                                                    if (cielleDemoVideo) {
                                                        cielleDemoVideo.currentTime = 0;
                                                        cielleDemoVideo.pause();
                                                    }
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="index.html"], .nav-link[href="#home"]`);
                                                } else if (viewName === 'contact') {
                                                if (contactSectionInternal) contactSectionInternal.classList.remove('hidden');
                                                    activeNavLink = document.querySelector(`.nav-link[href="#contact"]`);
                                            // --- NEW: Handle document view ---
                                            } else if (viewName === 'document') {
                                                if (documentSection) {
                                                    console.log(`[showView] Attempting to show documentSection. Current classes before remove: ${documentSection.className}`);
                                                    documentSection.classList.remove('hidden');
                                                    console.log(`[showView] documentSection classes after remove: ${documentSection.className}`);
                                                    // Check visibility
                                                    const styles = window.getComputedStyle(documentSection);
                                                    console.log(`[showView] documentSection computed display style: ${styles.display}, opacity: ${styles.opacity}, visibility: ${styles.visibility}`);
                                                    loadDocuments(); // Load documents when the section is shown
                                                } else {
                                                     console.error("[showView] documentSection element not found when trying to show 'document' view.");
                                                }
                                                activeNavLink = document.querySelector(`.nav-link[href="#document"]`);
                                            // --- END NEW ---
                                                } else { // Default to home
                                                    showView('home');
                                                }

                                                if (activeNavLink) {
                                                    activeNavLink.classList.add('active');
                                                    const mobileEquivalent = document.querySelector(`#mobile-menu a[href="${activeNavLink.getAttribute('href')}"]`);
                                                if (mobileEquivalent) mobileEquivalent.classList.add('active');
                                                }
                                            }

                                            // --- Routing and Event Listeners ---
                                            function handleNavigation() {
                                                const hash = window.location.hash || '#home';
                                                if (hash.startsWith('#blog/')) {
                                                    const postSlug = decodeURIComponent(hash.substring('#blog/'.length)); // Decode slug
                                                if (postSlug) loadPostDetail(postSlug); else showView('blog');
                                                } else if (hash === '#blog') {
                                                    showView('blog');
                                                } else if (hash === '#contact') {
                                                    showView('contact');
                                            } else if (hash === '#kyosuke-profile') {
                                                showView('kyosuke-profile');
                                            } else if (hash === '#CIELLE-profile') { // 新增CIELLE路由
                                                showView('cielle-profile');
                                                } else if (hash === '#document') { // --- NEW: Handle document route ---
                                                    showView('document');
                                                // --- END NEW ---
                                                } else { // Default to home
                                                    showView('home');
                                                }
                                            }
                                            

                                            document.addEventListener('DOMContentLoaded', () => {
                                            console.log('[DEBUG Frontend] DOMContentLoaded event fired.'); // Log DOMContentLoaded start

                                            // Initialize ALL DOM element variables AT THE TOP
                                            latestPostsGrid = document.getElementById('latest-posts-grid');
                                            // allPostsContent = document.getElementById('all-posts-content'); // This was too generic
                                            tagCloudContainer = document.querySelector('.tag-cloud'); // More specific selector
                                            // categoryListContainer = document.getElementById('category-list-container'); // Not used currently
                                            homeSection = document.getElementById('home');
                                            blogSection = document.getElementById('blog');
                                            postDetailSection = document.getElementById('post-detail-section');
                                            postDetailContentContainer = document.getElementById('post-detail-content-container');
                                            backToBlogListButton = document.getElementById('back-to-blog-list');
                                            kyosukeProfileSection = document.getElementById('kyosuke-profile-section');
                                            kyosukeProfileContent = document.getElementById('kyosuke-profile-content');
                                            kyosukeGender = document.getElementById('kyosuke-gender');
                                            kyosukeBirthday = document.getElementById('kyosuke-birthday');
                                            kyosukeHobbies = document.getElementById('kyosuke-hobbies');
                                            kyosukeTechStackContainer = document.getElementById('kyosuke-tech-stack');
                                            kyosukeEducationContainer = document.getElementById('kyosuke-education');
                                            kyosukeWorkExperienceContainer = document.getElementById('kyosuke-work-experience');
                                            blogListView = document.getElementById('blog-list-view');
                                            blogGridView = document.getElementById('blog-grid-view'); // Initialize grid view
                                            blogCalendarView = document.getElementById('blog-calendar-view'); // Initialize calendar view
                                            navLinks = document.querySelectorAll('.nav-link');
                                            mobileNavLinks = document.querySelectorAll('#mobile-menu a');
                                            contactSectionInternal = document.getElementById('contact'); // Initialize contact section for showView
                                            blogSort = document.getElementById('blog-sort');
                                            searchInput = document.getElementById('blog-search');
                                            blogLabelFilter = document.getElementById('blog-label-filter');
                                            newPostBtn = document.getElementById('btn-new-post');
                                            blogEditorModal = document.getElementById('blog-editor-modal');
                                            closeEditorBtn = document.getElementById('close-editor');
                                            savePostBtn = document.getElementById('save-post-button');
                                            blogTitleInput = document.getElementById('blog-title-editor');
                                            blogContentInput = document.getElementById('blog-content-editor');
                                            blogLabelSelect = document.getElementById('blog-category-editor');
                                            blogTagsInput = document.getElementById('blog-tags-editor');
                                            blogDateInput = document.getElementById('blog-date-editor');
                                            mdFileInput = document.getElementById('md-file-input');
                                            uploadMdBtn = document.getElementById('btn-upload-md');
                                            contributionGraph = document.getElementById('contribution-graph');
                                            backToHomeFromKyosukeButton = document.getElementById('back-to-home-from-kyosuke');
                                            contributionGraphActivity = document.getElementById('contribution-graph-activity');
                                            contributionGraphFrequency = document.getElementById('contribution-graph-frequency');
                                            cielleProfileSection = document.getElementById('cielle-profile-section');
                                            cielleDemoVideo = document.getElementById('cielle-demo-video');
                                            backToHomeFromCielleButton = document.getElementById('back-to-home-from-cielle');

                                            // --- NEW: Initialize Document Section DOM elements (Ensure these are initialized here) ---
                                            documentSection = document.getElementById('document'); // {{ edit_1 }} // Correctly point to the main section
                                            documentSearchInput = document.getElementById('document-search');
                                            documentTypeFilter = document.getElementById('document-type-filter');
                                            documentSortSelect = document.getElementById('document-sort');
                                            documentListContainer = document.getElementById('document-list'); // This remains the list container
                                            documentViewerModal = document.getElementById('document-viewer-modal');
                                            closeViewerBtn = document.getElementById('close-viewer');
                                            viewerTitle = document.getElementById('viewer-title');
                                            viewerContent = document.getElementById('viewer-content');
                                            viewerContentWrapper = document.getElementById('viewer-content-wrapper');
                                            downloadDocumentButton = document.getElementById('download-document-button');
                                            // --- END NEW ---

                                            // Editor Modal Elements Initialization
                                            editorTitle = document.getElementById('editor-title');
                                            originalPostTitleInput = document.getElementById('original-post-title');
                                            blogTitleEditor = document.getElementById('blog-title-editor');
                                            blogCategoryEditor = document.getElementById('blog-category-editor'); // This ID needs to be in the modal HTML
                                            blogTagsEditor = document.getElementById('blog-tags-editor'); // This ID needs to be in the modal HTML
                                            blogDateEditor = document.getElementById('blog-date-editor'); // This ID needs to be in the modal HTML
                                            blogContentEditor = document.getElementById('blog-content-editor');
                                            savePostButton = document.getElementById('save-post-button');
                                            markdownPreviewArea = document.getElementById('markdown-preview-area');
                                            blogLabelFilterElement = document.getElementById('blog-label-filter'); // Initialize here


                                            // Call loading functions after DOM elements are assigned
                                            loadLatestPosts();
                                            loadAllBlogPosts(); // This should now work
                                            loadTags();
                                            loadBlogLabelFilterCategories(); // Load categories for the blog filter
                                            loadCategoriesIntoEditor(); // Ensure editor categories are loaded on init (or when modal opens)
                                            setupContributionGraph(); // Call function to set up graph

                                            handleNavigation(); // Initial view setup
                                            window.addEventListener('hashchange', handleNavigation);

                                            // Event listeners
                                            if (backToBlogListButton) { // MODIFIED: Add event listener for back to blog list button
                                                backToBlogListButton.addEventListener('click', () => {
                                                    window.location.hash = '#blog';
                                                });
                                            }
                                            if (backToHomeFromKyosukeButton) {
                                                backToHomeFromKyosukeButton.addEventListener('click', () => {
                                                    window.location.hash = '#home';
                                                });
                                            }
                                            if (backToHomeFromCielleButton) { // CIELLE页返回按钮事件
                                                backToHomeFromCielleButton.addEventListener('click', () => {
                                                    window.location.hash = '#home';
                                                });
                                            }
                                            if (searchInput) {
                                                searchInput.addEventListener('input', debounce(function () {
                                                    const activeTags = Array.from(document.querySelectorAll('.tag.active')).map(tag => tag.dataset.tag);
                                                    const selectedCategory = blogLabelFilter ? blogLabelFilter.value : 'all';
                                                    loadAllBlogPosts(this.value, activeTags, selectedCategory === 'all' ? '' : selectedCategory);
                                                }, 300));
                                            }
                                            if (tagCloudContainer) { /* ... tag cloud event listener ... */ }
                                            if (categoryListContainer) { /* ... category list event listener ... */ }
                                            if (blogSort) {
                                                blogSort.addEventListener('change', function () {
                                                    const searchTerm = searchInput ? searchInput.value : '';
                                                    const activeTagsElements = tagCloudContainer ? tagCloudContainer.querySelectorAll('.tag.active') : [];
                                                    const activeTags = Array.from(activeTagsElements)
                                                                          .map(tagEl => tagEl.dataset.tagName) // Use data-tag-name
                                                                          .filter(name => name && name !== 'すべて'); // Filter out "すべて" and empty
                                                    const selectedCategory = blogLabelFilter ? blogLabelFilter.value : 'all';
                                                    loadAllBlogPosts(searchTerm, activeTags, selectedCategory === 'all' ? '' : selectedCategory);
                                                });
                                            }
                                            if (blogLabelFilter) {
                                               blogLabelFilter.addEventListener('change', function () {
                                                    const searchTerm = searchInput ? searchInput.value : '';
                                                    const activeTagsElements = tagCloudContainer ? tagCloudContainer.querySelectorAll('.tag.active') : [];
                                                    const activeTags = Array.from(activeTagsElements)
                                                                          .map(tagEl => tagEl.dataset.tagName) // Use data-tag-name
                                                                          .filter(name => name && name !== 'すべて'); // Filter out "すべて" and empty
                                                    loadAllBlogPosts(searchTerm, activeTags, this.value === 'all' ? '' : this.value);
                                                });
                                            }


                                            if (newPostBtn && blogEditorModal) {
                                                newPostBtn.addEventListener('click', openNewPostModal);
                                            }
                                            if (closeEditorBtn && blogEditorModal) {
                                                closeEditorBtn.addEventListener('click', () => {
                                                    blogEditorModal.classList.add('hidden');
                                                    if (easymde) { // MODIFIED: Cleanup EasyMDE
                                                        easymde.toTextArea();
                                                        easymde = null;
                                                    }
                                                    window.currentSessionPastedAssets = []; 
                                                    currentEditorSessionId = null; 
                                                    removeCtrlSListener(); // REMOVE Ctrl+S listener when closing editor
                                                });
                                            }
                                            if (savePostButton) {
                                                 savePostButton.addEventListener('click', handleSavePost);
                                            }
                                            document.body.addEventListener('click', function (event) {
                                                if (event.target.matches('.post-detail-link')) {
                                                    event.preventDefault();
                                                    window.location.hash = `blog/${event.target.dataset.postSlug}`; // Use slug from data attribute
                                                } else if (event.target.closest('.edit-post-btn')) {
                                                    event.preventDefault();
                                                    const postTitle = event.target.closest('.edit-post-btn').dataset.postTitle;
                                                    openEditPostModal(decodeURIComponent(postTitle));
                                                } else if (event.target.closest('.delete-post-btn')) {
                                                    event.preventDefault();
                                                    const button = event.target.closest('.delete-post-btn'); // Get the button element
                                                    const postTitle = button.dataset.postTitle;           // Get title
                                                    const postId = button.dataset.postId;                 // Get ID
                                                    handleDeletePost(decodeURIComponent(postTitle), postId); // Pass both title and ID
                                                }
                                            });
                                             // Mobile menu toggle (this one is fine here or in the first script tag)
                                            const menuToggle = document.getElementById('menu-toggle');
                                            const mobileMenu = document.getElementById('mobile-menu');
                                            if (menuToggle && mobileMenu) {
                                                menuToggle.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));
                                                mobileMenu.querySelectorAll('a').forEach(link => {
                                                    link.addEventListener('click', () => mobileMenu.classList.add('hidden'));
                                                });
                                            }

                                            // Setup blog view tabs
                                            const blogViewTabs = document.querySelectorAll('.blog-view-tab');
                                            blogViewTabs.forEach(tab => {
                                                tab.addEventListener('click', function() {
                                                    blogViewTabs.forEach(t => {
                                                        t.classList.remove('border-black');
                                                        t.classList.add('border-transparent');
                                                    });
                                                    this.classList.remove('border-transparent');
                                                    this.classList.add('border-black');
                                                    
                                                    activeBlogView = this.dataset.view;
                                                    
                                                    if (blogListView) blogListView.classList.add('hidden');
                                                    if (blogGridView) blogGridView.classList.add('hidden');
                                                    // if (blogCalendarView) blogCalendarView.classList.add('hidden'); // REMOVED

                                                    if (activeBlogView === 'list' && blogListView) blogListView.classList.remove('hidden');
                                                    else if (activeBlogView === 'grid' && blogGridView) blogGridView.classList.remove('hidden');
                                                    // else if (activeBlogView === 'calendar' && blogCalendarView) { // REMOVED
                                                    //      blogCalendarView.classList.remove('hidden');
                                                    //      // setupCalendarView(); 
                                                    // }
                                                    loadAllBlogPosts(searchInput.value, 
                                                                     Array.from(tagCloudContainer.querySelectorAll('.tag.active')).map(tagEl => tagEl.textContent.trim() === 'すべて' ? '' : tagEl.textContent.trim()).filter(Boolean), 
                                                                     blogLabelFilter.value === 'all' ? '' : blogLabelFilter.value,
                                                                     1); // Reset to page 1 on view change
                                                });
                                            });

                                            // Set the default active tab and view
                                            const defaultActiveTab = document.querySelector('.blog-view-tab[data-view="list"]');
                                            if (defaultActiveTab && blogListView) {
                                                defaultActiveTab.click(); // Simulate click to set active styles and load data
                                                // blogListView.classList.remove('hidden'); // Ensure it's visible initially
                                            }

                                            // Initialize Markdown preview and paste listener
                                            // if (blogContentEditor && markdownPreviewArea) { // REMOVED: This block is largely replaced by EasyMDE
                                                // Debounced function for preview
                                                // const debouncedUpdatePreview = debounce(updateMarkdownPreview, 300);
                                                // blogContentEditor.addEventListener('input', debouncedUpdatePreview);
                                                
                                                // Paste listener for images
                                                // blogContentEditor.addEventListener('paste', handlePasteImageInEditor);

                                                // Initial preview render if modal opens with content (e.g., on edit)
                                                // This will be triggered by openEditPostModal setting content and then calling update manually if needed
                                            // }
                                            // Configure Marked - This setup is still important for EasyMDE's previewRender
                                            if (typeof marked !== 'undefined') {
                                                const renderer = new marked.Renderer();
                                                const originalImageRenderer = renderer.image;
                                                renderer.image = (href, title, text) => {
                                                    console.log("渲染图片，参数类型:", typeof href, "值:", href);
                                                    
                                                    // 如果href是对象而不是字符串，尝试从对象中获取正确的属性
                                                    if (href && typeof href === 'object' && href.href) {
                                                        console.log("href是对象，使用href.href属性:", href.href);
                                                        text = href.text || text;
                                                        title = href.title || title;
                                                        href = href.href;
                                                    }
                                                    
                                                    // 确保href现在是字符串
                                                    if (!href || typeof href !== 'string') {
                                                        console.warn('无效的图片链接:', href);
                                                        return `<img src="" alt="${text || '图片加载失败'}" title="无效的图片链接" class="max-w-full h-auto my-4 border border-red-300 p-2 text-center text-red-500">`;
                                                    }

                                                    const baseUrlForAssets = API_BASE_URL.replace('/api', ''); // http://127.0.0.1:5000

                                                    if (href.startsWith('./assets/')) {
                                                        let previewSrc = "";
                                                        if (currentEditorSessionId) {
                                                            // If in an active editing session, resolve relative paths against the temp session asset URL
                                                            previewSrc = `${baseUrlForAssets}/temp_assets/${currentEditorSessionId}/${href.substring(2)}`; // remove './'
                                                        } else if (blogTitleEditor.value.trim()) {
                                                            // If not in a session (e.g. just opened an old post for viewing in modal, or title is available for an existing post)
                                                            // and it's an existing post whose title is known for asset path construction
                                                            previewSrc = `${baseUrlForAssets}/blog_assets/${encodeURIComponent(blogTitleEditor.value.trim())}/${href.substring(2)}`;
                                                        } else {
                                                            // Cannot resolve relative path for preview yet.
                                                            return `<img src="" alt="${text}" title="タイトルを入力するか、セッションが開始されると、ここに画像プレビューが表示されます。" class="max-w-full h-auto my-4 p-4 border border-dashed rounded text-center text-gray-500"> <p class="text-xs text-center text-gray-500">(プレビュー不可)</p>`;
                                                        }
                                                        previewSrc += `?t=${new Date().getTime()}`;
                                                        return `<img src="${previewSrc}" alt="${text}"${title ? ` title="${title}"` : ''} class="max-w-full h-auto my-4 rounded shadow">`;

                                                    } else if (href.startsWith('/temp_assets/') || href.startsWith('/blog_assets/')) {
                                                        // If the href is ALREADY an absolute path to a server asset (e.g. from backend's previewUrl)
                                                        // Ensure it has the base URL if it doesn't already
                                                        let fullHref = href;
                                                        if (!href.startsWith(baseUrlForAssets)){
                                                             fullHref = baseUrlForAssets + href;
                                                        }
                                                        fullHref += `?t=${new Date().getTime()}`;
                                                        return `<img src="${fullHref}" alt="${text}"${title ? ` title="${title}"` : ''} class="max-w-full h-auto my-4 rounded shadow">`;
                                                    }
                                                    
                                                    // For external images or other paths, use default behavior
                                                    // or handle them as absolute URLs if they are (e.g. http://, https://)
                                                    if (href.match(/^https?:\/\//i)) {
                                                         return originalImageRenderer.call(renderer, href, title, text);
                                                    }
                                                    // If it's some other kind of relative path not starting with ./assets, it might be broken for preview
                                                    // or meant for a different context. Default renderer might show broken link.
                                                    return originalImageRenderer.call(renderer, href, title, text);
                                                };

                                                renderer.text = function(text) {
                                                    // ... existing code ...
                                                };

                                                marked.setOptions({
                                                    renderer: renderer,
                                                    gfm: true,
                                                    breaks: true,
                                                    sanitize: false,
                                                    smartLists: true,
                                                    smartypants: false
                                                });
                                            }

                                        }); // End of DOMContentLoaded

                                        // Markdown editor helper functions (can be here)
                                        // function formatText(prefix, suffix, textareaId = 'blog-content-editor') { // REMOVED
                                        // ...
                                        // }
                                        // function insertImage(textareaId = 'blog-content-editor') { // REMOVED
                                        // ...
                                        // }

                                        // --- NEW CRUD FUNCTIONS & Editor Logic ---
                                        let currentEditorMode = 'create'; // 'create' or 'edit'

                                        async function loadCategoriesIntoEditor() {
                                            const categories = await fetchData('/labels'); // Fetches {name, color}
                                            if (blogCategoryEditor) {
                                                if (categories && categories.length > 0) {
                                                    blogCategoryEditor.innerHTML = categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
                                                } else {
                                                    blogCategoryEditor.innerHTML = '<option value="">カテゴリなし</option>';
                                                }
                                            } else {
                                                console.warn("blogCategoryEditor element not found.");
                                            }
                                        }
                                        
                                        function openNewPostModal() {
                                            currentEditorMode = 'create';
                                            currentEditorSessionId = `session_${new Date().getTime()}_${Math.random().toString(36).substring(2, 10)}`;
                                            window.currentEditorSessionId = currentEditorSessionId;
                                            window.currentSessionPastedAssets = []; 
                                            
                                            console.log("创建新文章，会话ID:", currentEditorSessionId);
                                            if (editorTitle) editorTitle.textContent = '新規ブログ投稿を作成';
                                            if (originalPostTitleInput) originalPostTitleInput.value = '';
                                            if (blogTitleEditor) blogTitleEditor.value = '';
                                            
                                            // MODIFIED: Initialize EasyMDE
                                            if (easymde) {
                                                easymde.toTextArea();
                                                easymde = null;
                                            }
                                            easymde = initializeEasyMDE(''); // Pass empty content for new post

                                            if (blogCategoryEditor) {
                                                if (blogCategoryEditor.options.length <= 1 || (blogCategoryEditor.options.length > 0 && blogCategoryEditor.options[0].value === "")) {
                                                     loadCategoriesIntoEditor().then(() => {
                                                        if (blogCategoryEditor.options.length > 0) blogCategoryEditor.selectedIndex = 0;
                                                     });
                                                } else {
                                                     if (blogCategoryEditor.options.length > 0) blogCategoryEditor.selectedIndex = 0;
                                                }
                                            }
                                            if (blogTagsEditor) blogTagsEditor.value = '';
                                            if (blogDateEditor) blogDateEditor.value = new Date().toISOString().split('T')[0];
                                            if (blogEditorModal) blogEditorModal.classList.remove('hidden');
                                            
                                            startAutoSave(); // 新建时启动自动保存
                                            setupCtrlSListener(); // 设置Ctrl+S监听
                                        }

                                        async function openEditPostModal(postTitleOrSlug) { // Parameter can be title or slug
                                            const post = await fetchData(`/post/${encodeURIComponent(postTitleOrSlug)}`);
                                            if (post && !post.error) {
                                                currentEditorMode = 'edit';
                                                // Store the current slug of the post being edited
                                                window.currentEditingPostSlug = post.slug; 
                                                console.log("Editing post. Current slug set to:", window.currentEditingPostSlug);

                                                // For edit, session_id is not strictly for temp asset storage location on backend,
                                                // but can still be used for client-side tracking of assets pasted in *this* session if needed.
                                                currentEditorSessionId = `session_edit_${post.slug}_${new Date().getTime()}`;
                                                window.currentEditorSessionId = currentEditorSessionId; // For client-side asset tracking
                                                window.currentSessionPastedAssets = []; 
                                                
                                                console.log("編集文章，会话ID (for client tracking):", currentEditorSessionId, "原标题:", post.title);
                                                if (editorTitle) editorTitle.textContent = 'ブログ投稿を編集';
                                                if (originalPostTitleInput) originalPostTitleInput.value = post.title; // Store original title (used as key if slug changes)
                                                if (blogTitleEditor) blogTitleEditor.value = post.title;
                                                
                                                if (easymde) {
                                                    easymde.toTextArea();
                                                    easymde = null;
                                                }
                                                easymde = initializeEasyMDE(post.content_md || '');
                                                
                                                if (blogCategoryEditor) {
                                                    await loadCategoriesIntoEditor(); // Ensure categories are loaded
                                                    blogCategoryEditor.value = post.category || "";
                                                }
                                                if (blogTagsEditor) blogTagsEditor.value = Array.isArray(post.tags) ? post.tags.join(', ') : '';
                                                if (blogDateEditor) {
                                                    // Backend sends date as "YYYY年MM月DD日"
                                                    // Convert to "YYYY-MM-DD" for input type="date"
                                                    if (post.date) {
                                                        const match = post.date.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/);
                                                        if (match) {
                                                            const year = match[1];
                                                            const month = match[2].padStart(2, '0');
                                                            const day = match[3].padStart(2, '0');
                                                            blogDateEditor.value = `${year}-${month}-${day}`;
                                                        } else {
                                                            blogDateEditor.value = new Date().toISOString().split('T')[0]; // fallback
                                                        }
                                                    } else {
                                                        blogDateEditor.value = new Date().toISOString().split('T')[0]; // fallback
                                                    }
                                                }
                                                
                                                if (blogEditorModal) blogEditorModal.classList.remove('hidden');
                                                // No autoSave on edit open, user explicit save. Or implement if desired.
                                                setupCtrlSListener();
                                            } else {
                                                alert(`投稿「${postTitleOrSlug}」の読み込みに失敗しました: ${post ? post.error : '不明なエラー'}`);
                                                window.currentEditingPostSlug = null; // Clear it
                                            }
                                        }
                                        // Basic HTML to Markdown (very simplified, consider a library for complex cases)
                                        // 不再需要 convertHtmlToMarkdown 函数，可以删除
                                        /*
                                        function convertHtmlToMarkdown(html) {
                                            if (!html) return '';
                                            let md = html;
                                            // ... (implementation) ...
                                            return md.trim();
                                        }
                                        */

                                        let autoSaveInterval = null;
                                        let isSaving = false; // 防止并发保存

                                        async function handleSavePost(options = { showSuccessAlert: true }) {
                                            if (isSaving) {
                                                console.log("保存操作正在进行中，请稍候...");
                                                if (options.showSuccessAlert) { // 只有在手动保存时才提示用户
                                                    alert("正在保存，请稍候...");
                                                }
                                                return;
                                            }
                                            isSaving = true;

                                            if (!easymde) {
                                                alert('エディタが初期化されていません。');
                                                isSaving = false;
                                                return;
                                            }
                                            const title = blogTitleEditor.value.trim();
                                            const content = easymde.value(); 
                                            const category = blogCategoryEditor.value;
                                            const tags = blogTagsEditor.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                                            const date = blogDateEditor.value;

                                            if (!title && options.showSuccessAlert) { // 内容和分类可以后续补充，但标题在手动保存时最好有
                                                alert('タイトルは必須です。');
                                                isSaving = false;
                                                return;
                                            }
                                            // 对于自动保存，即使没有标题也尝试保存（如果内容存在）
                                            if (!title && !content && !options.showSuccessAlert) {
                                                console.log("自动保存：标题和内容均为空，不执行保存。");
                                                isSaving = false;
                                                return;
                                            }


                                            const postData = { 
                                                title, 
                                                content, 
                                                category, 
                                                tags, 
                                                date, 
                                                session_id: currentEditorSessionId 
                                            };
                                            
                                            console.log("DEBUG: Content being sent to backend (handleSavePost):", content.substring(0,100)); 
                                            
                                            let response;
                                            let endpoint = '';
                                            let method = '';

                                            try {
                                                if (currentEditorMode === 'create' && !originalPostTitleInput.value) { // 确保是真正的创建
                                                    endpoint = `${API_BASE_URL}/post`;
                                                    method = 'POST';
                                                } else { 
                                                    // 如果 originalPostTitleInput 有值，说明是编辑
                                                    // 或者 currentEditorMode 是 'edit' (更可靠)
                                                    const originalTitle = originalPostTitleInput.value || title; // 如果 original 为空但 title 有值 (首次自动保存创建的)
                                                    if (!originalTitle) {
                                                        // 如果是 'create' 模式，但 originalPostTitleInput.value 为空，且 title 也为空 (不太可能到这里)
                                                        // 或者这是一个刚刚通过自动保存 "创建"（但后端认为是更新因为它有了ID/title）的帖子
                                                        // 这种情况下，我们更倾向于认为是 "更新" (PUT) 一个已经存在的（哪怕是刚创建的）帖子
                                                        // 需要后端确保 /post (POST) 返回的 title 被正确设置到 originalPostTitleInput.value
                                                        console.warn("尝试更新，但 original_title 未明确。将使用当前标题作为原始标题。");
                                                        if (!title) {
                                                            console.error("错误：既无原始标题也无当前标题，无法保存。");
                                                            isSaving = false;
                                                            return;
                                                        }
                                                         endpoint = `${API_BASE_URL}/post/${encodeURIComponent(title)}`;
                                                    } else {
                                                    endpoint = `${API_BASE_URL}/post/${encodeURIComponent(originalTitle)}`;
                                                    }
                                                    method = 'PUT';
                                                    postData.original_title = originalTitle; 
                                                }

                                                response = await fetch(endpoint, {
                                                    method: method,
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify(postData)
                                                });

                                                const result = await response.json();
                                                if (response.ok && result.success) {
                                                    if (options.showSuccessAlert) {
                                                        // Updated console log based on backend response
                                                        if (result.asset_move_status === 'success' && result.assets_moved_count > 0) {
                                                            console.log(`[Backend]: ${result.assets_moved_count} 画像が正常に移動されました。投稿: ${result.slug}`);
                                                        } else if (result.asset_move_status === 'success' && result.assets_moved_count === 0) {
                                                            console.log(`[Backend]: 移動する画像はありませんでした (または、以前に移動済み)。投稿: ${result.slug}`);
                                                        } else if (result.asset_move_status === 'temp_dir_not_found' || result.asset_move_status === 'temp_dir_empty') {
                                                            console.log(`[Backend]: 一時フォルダに移動する画像はありませんでした。投稿: ${result.slug}`);
                                                        } else if (result.asset_move_status && result.asset_move_status !== 'not_attempted' && result.asset_move_status !== 'no_session_id') {
                                                            console.warn(`[Backend]: 画像移動の試行結果: ${result.asset_move_status}, 移動数: ${result.assets_moved_count}。詳細はバックエンドログを確認してください。投稿: ${result.slug}`);
                                                        }
                                                        // else: asset_move_status might be 'not_attempted' or 'no_session_id', in which case no specific asset log from backend is needed here.

                                                        const alertMessage = (currentEditorMode === 'create' && method === 'POST') 
                                                                           ? '投稿が作成されました！画像も保存されました。' 
                                                                           : '投稿が更新されました！画像も保存されました。';
                                                        alert(alertMessage);
                                                } else {
                                                        console.log("自动保存成功:", new Date().toLocaleTimeString());
                                                        // 可以考虑在这里给用户一个微小的反馈，比如状态栏提示"已保存"
                                                    }
                                                    // 如果是创建操作且成功，更新 originalPostTitleInput 和模式，以便后续保存是更新
                                                    if (method === 'POST' && result.title) {
                                                        originalPostTitleInput.value = result.title;
                                                        currentEditorMode = 'edit'; // 后续保存都视为编辑此刚创建的帖子
                                                        // 更新浏览器URL中的slug (如果实现了slug的创建和返回)
                                                        // if(result.slug) history.replaceState(null, null, `#blog/${result.slug}`);
                                                    }

                                                    // 对于非弹窗的保存，不需要关闭模态框或刷新列表
                                                    if (options.showSuccessAlert) {
                                                        blogEditorModal.classList.add('hidden');
                                                        if (easymde) { easymde.toTextArea(); easymde = null; }
                                                        window.currentSessionPastedAssets = []; 
                                                        currentEditorSessionId = null; 
                                                        loadAllBlogPosts(); 
                                                        loadLatestPosts();  
                                                        loadTags();  
                                                    }       
                                                } else {
                                                    if (options.showSuccessAlert) {
                                                        alert(`エラー: ${result.error || response.statusText}`);
                                                    } else {
                                                        console.error("自动保存失败:", result.error || response.statusText);
                                                    }
                                                }
                                            } catch (error) {
                                                console.error('保存エラー:', error);
                                                if (options.showSuccessAlert) {
                                                    alert('投稿の保存中にエラーが発生しました。');
                                                }
                                            } finally {
                                                isSaving = false;
                                            }
                                        }

                                        async function handleDeletePost(postTitle, postId) { // Added postId parameter
                                            // MODIFIED: Use post ID in the confirmation message and the fetch URL
                                            if (!postId) {
                                                alert("削除する投稿のIDが見つかりません。");
                                                return;
                                            }
                                            if (!confirm(`投稿「${postTitle}」(ID: ${postId}) を削除してもよろしいですか？`)) return;

                                            try {
                                                // MODIFIED: Use post ID in the URL
                                                const response = await fetch(`${API_BASE_URL}/post/${postId}`, {
                                                    method: 'DELETE'
                                                });
                                                
                                                // MODIFIED: Improved error handling for non-OK responses
                                                if (!response.ok) {
                                                    // If response is not ok, read the body as text to see the error
                                                    const errorText = await response.text();
                                                    console.error("DELETE request failed:", response.status, response.statusText, "Body:", errorText);
                                                     // Check if it's a login redirect by looking for HTML content
                                                    if (errorText.trim().startsWith('<!doctype html>')) {
                                                         alert('您需要登录才能删除文章。');
                                                         // Optionally redirect to login page:
                                                         // window.location.href = `${API_BASE_URL.replace('/api', '')}/login?next=${encodeURIComponent(window.location.pathname + window.location.hash)}`;
                                                    } else {
                                                         alert(`删除失败: ${response.status} ${response.statusText} - ${errorText.substring(0, Math.min(errorText.length, 200))}...`); // Limit error text length
                                                    }
                                                    return; // Stop processing
                                                }

                                                // If response is OK, proceed to parse JSON
                                                const result = await response.json();

                                                if (result.success) {
                                                    alert('投稿が削除されました。');
                                                    // Refresh the blog list, latest posts, and tags after successful deletion
                                                    loadAllBlogPosts();
                                                    loadLatestPosts();
                                                    loadTags();
                                                } else {
                                                    // Handle cases where the server returns success: false with a JSON error message
                                                    alert(`削除エラー: ${result.error || '不明なエラー'}`);
                                                }
                                            } catch (error) {
                                                // Catch network errors or errors during response processing (like SyntaxError)
                                                console.error('削除エラー:', error);
                                                alert('投稿の削除中にエラーが発生しました。ネットワークエラー或服务器响应异常。');
                                            }
                                        }
                                        
                                        async function handleMarkdownFileUpload(event) {
                                            const file = event.target.files[0];
                                            if (!file) return;

                                            if (!file.name.endsWith('.md')) {
                                                alert('Markdown (.md) ファイルを選択してください。');
                                                return;
                                            }
                                            
                                            // Use editor modal to get metadata, or a simpler prompt
                                            // For now, let's prompt for simplicity, can be expanded to use modal
                                            const title = prompt("投稿のタイトルを入力してください:", file.name.replace('.md', ''));
                                            if (!title) return; // User cancelled
                                            
                                            const categories = await fetchData('/labels');
                                            let categoryPromptMessage = "カテゴリを選択してください:\n";
                                            if (categories && categories.length > 0) {
                                                categoryPromptMessage += categories.map((cat, i) => `${i + 1}. ${cat.name}`).join('\n');
                                            } else {
                                                categoryPromptMessage += "利用可能なカテゴリがありません。デフォルトを使用します。";
                                            }
                                            const categoryInput = prompt(categoryPromptMessage, categories && categories.length > 0 ? categories[0].name : "General");
                                            if (!categoryInput) return; // User cancelled

                                            const tags = prompt("タグをカンマ区切りで入力してください (例: tech, ai):", "");
                                            
                                            const formData = new FormData();
                                            formData.append('file', file);
                                            formData.append('title', title);
                                            formData.append('category', categoryInput);
                                            formData.append('tags', tags || "");

                                            try {
                                                const response = await fetch(`${API_BASE_URL}/upload`, {
                                                    method: 'POST',
                                                    body: formData
                                                });
                                                const result = await response.json();
                                                if (response.ok && result.success) {
                                                    alert('Markdown ファイルがアップロードされ、投稿が作成されました！');
                                                    loadAllBlogPosts();
                                                    loadLatestPosts();
                                                    loadTags();
                                                } else {
                                                    alert(`アップロードエラー: ${result.error || response.statusText}`);
                                                }
                                            } catch (error) {
                                                console.error('アップロードエラー:', error);
                                                alert('ファイルのアップロード中にエラーが発生しました。');
                                            } finally {
                                                mdFileInput.value = ''; // Reset file input
                                            }
                                        }
                                        // --- End of NEW CRUD FUNCTIONS & Editor Logic ---

                                        // 新增：渲染技术栈
                                        function renderKyosukeTechStack(skills) {
                                            if (!kyosukeTechStackContainer || !skills || skills.length === 0) {
                                                if(kyosukeTechStackContainer) kyosukeTechStackContainer.innerHTML = '<p>技術スタック情報はありません。</p>';
                                                return;
                                            }
                                            
                                            // Step 1: Create the initial HTML with 0 width for animation
                                            kyosukeTechStackContainer.innerHTML = skills.map((skill, index) => `
                                                <div class="skill-item mb-4">
                                                    <div class="flex justify-between items-center mb-1">
                                                        <span class="text-base font-medium text-gray-800">${skill.name}
                                                            ${skill.note ? `<span class="text-xs text-gray-500 font-normal italic ml-1">- ${skill.note}</span>` : ''}
                                                        </span>
                                                        <span class="text-sm font-medium text-gray-700 sr-only">${skill.percent}%</span>
                                                    </div>
                                                    <div class="w-full bg-gray-200 rounded-full h-5 overflow-hidden">
                                                        <div id="skill-bar-${index}" 
                                                             class="h-full rounded-full flex items-center justify-end pr-3 text-white text-xs font-semibold transition-all duration-1000 ease-out" 
                                                             style="width: 0%; background-color: ${skill.color}; min-width: 2em;">
                                                            <span>${skill.percent}%</span>
                                                        </div>
                                                    </div>
                                                </div>
                                            `).join('');

                                            // Step 2: After a short delay, update the width to trigger the animation
                                            setTimeout(() => {
                                                skills.forEach((skill, index) => {
                                                    const barElement = document.getElementById(`skill-bar-${index}`);
                                                    if (barElement) {
                                                        barElement.style.width = `${skill.percent}%`;
                                                    }
                                                });
                                            }, 100); // 100ms delay, can be adjusted
                                        }

                                        // Tag Management Buttons
                                        const addNewTagBtn = document.getElementById('add-new-tag-btn');
                                        const toggleDeleteTagBtn = document.getElementById('toggle-delete-tag-btn');
                                        const confirmDeleteTagsBtn = document.getElementById('confirm-delete-tags-btn');
                                        const cancelDeleteTagsBtn = document.getElementById('cancel-delete-tags-btn');
                                        let tagDeleteMode = false;

                                        if (addNewTagBtn) {
                                            addNewTagBtn.addEventListener('click', async () => {
                                                const newTagName = prompt("追加する新しいタグ名を入力してください:");
                                                if (newTagName && newTagName.trim() !== "") {
                                                    try {
                                                        const response = await fetch(`${API_BASE_URL}/tags`, {
                                                            method: 'POST',
                                                            headers: { 'Content-Type': 'application/json' },
                                                            body: JSON.stringify({ name: newTagName.trim() })
                                                        });
                                                        const result = await response.json();
                                                        if (response.ok && result.success) {
                                                            alert(`タグ「${newTagName.trim()}」が追加されました。`);
                                                            loadTags(); // Refresh tag cloud
                                                        } else {
                                                            alert(`タグ追加エラー: ${result.error || response.statusText}`);
                                                        }
                                                    } catch (error) {
                                                        console.error("Error adding new tag:", error);
                                                        alert("タグの追加中にエラーが発生しました。");
                                                    }
                                                }
                                            });
                                        }

                                        if (toggleDeleteTagBtn) {
                                            toggleDeleteTagBtn.addEventListener('click', () => {
                                                tagDeleteMode = !tagDeleteMode;
                                                tagCloudContainer.querySelectorAll('.delete-tag-x').forEach(btn => {
                                                    btn.classList.toggle('hidden', !tagDeleteMode);
                                                });
                                                // Show/hide confirm/cancel buttons if you implement a multi-delete later
                                                // For now, the 'x' click directly calls deleteTagFromServer
                                                // If you want a "select multiple then delete" UX, these buttons would be used:
                                                // confirmDeleteTagsBtn.classList.toggle('hidden', !tagDeleteMode);
                                                // cancelDeleteTagsBtn.classList.toggle('hidden', !tagDeleteMode);
                                                // toggleDeleteTagBtn.textContent = tagDeleteMode ? '削除を完了' : 'タグを削除';
                                            });
                                        }
                                        
                                        // Function to delete a single tag from server
                                        async function deleteTagFromServer(tagName) {
                                            try {
                                                const response = await fetch(`${API_BASE_URL}/tags/${encodeURIComponent(tagName)}`, {
                                                    method: 'DELETE'
                                                });
                                                const result = await response.json();
                                                if (response.ok && result.success) {
                                                    alert(`タグ「${tagName}」が削除されました。`);
                                                    loadTags(); // Refresh tag cloud
                                                    loadAllBlogPosts(); // Refresh posts as their tags might have changed
                                                } else {
                                                    alert(`タグ削除エラー: ${result.error || response.statusText}`);
                                                }
                                            } catch (error) {
                                                console.error("Error deleting tag:", error);
                                                alert("タグの削除中にエラーが発生しました。");
                                            }
                                        }

                                        // If you implement multi-tag deletion:
                                        // if (confirmDeleteTagsBtn) { /* ... */ }
                                        // if (cancelDeleteTagsBtn) { /* ... */ }

                                        // --- Markdown Preview and Image Paste Logic ---
                                        // function updateMarkdownPreview() { // REMOVED: EasyMDE handles its own preview updates
                                            // ...
                                        // }

                                        async function handlePasteImageInEditor(event) { 
                                            // This function might be partially or fully replaced by EasyMDE's imageUploadFunction
                                            // For now, let's keep it, but the integration point is imageUploadFunction in initializeEasyMDE
                                            // If EasyMDE's paste handling is sufficient, this might not be directly called.
                                            // However, the core logic of uploading to /api/paste_image is still needed.
                                            // ... existing code ...
                                        }

                                        // 完全替换setupMarkedRenderer函数中的 renderer.image 部分
                                        function setupMarkedRenderer() {
                                            if (typeof marked !== 'undefined') {
                                                console.log("设置Marked渲染器...");
                                                
                                                const renderer = new marked.Renderer();
                                                const originalImageRenderer = renderer.image;
                                                
                                                renderer.image = function(href, title, text) {
                                                    console.log("渲染图片调用", {href, title, text, type: typeof href});
                                                    
                                                    if (href && typeof href === 'object') {
                                                        if (href.href) {
                                                            const objHref = href.href;
                                                            const objTitle = href.title || title;
                                                            const objText = href.text || text;
                                                            return this.image(objHref, objTitle, objText); 
                                                        } else {
                                                            console.warn("href是对象但没有href属性:", href);
                                                            return `<img src="" alt="无效图片" class="border border-red-500 p-2">`;
                                                        }
                                                    }

                                                    if (!href || typeof href !== 'string') {
                                                        console.warn('无效的图片链接值:', href);
                                                        return `<img src="" alt="${text || '图片加载失败'}" title="无效的图片链接" class="max-w-full h-auto my-4 border border-red-300 p-2 text-center text-red-500">`;
                                                    }

                                                    const baseUrlForAssets = API_BASE_URL.replace('/api', '');
                                                    
                                                    if (href.startsWith('./assets/')) {
                                                        let previewSrc = "";
                                                        const imageName = href.substring('./assets/'.length);

                                                        if (!window.currentSessionPastedAssets) {
                                                            window.currentSessionPastedAssets = [];
                                                        }
                                                        const pastedAssetInfo = window.currentSessionPastedAssets.find(p => p.markdownPath === href);

                                                        if (pastedAssetInfo) {
                                                            // 图片是在当前会话中粘贴的
                                                            previewSrc = pastedAssetInfo.previewUrl; 
                                                            if (!previewSrc.startsWith(baseUrlForAssets)) {
                                                                previewSrc = baseUrlForAssets + previewSrc;
                                                            }
                                                            console.log("使用当前会话粘贴的图片预览URL:", previewSrc);
                                                        } else if (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) {
                                                            // 编辑模式，且图片不是当前会话粘贴的 -> 属于原文的图片
                                                            previewSrc = `${baseUrlForAssets}/blog_assets/${encodeURIComponent(originalPostTitleInput.value)}/assets/${imageName}`;
                                                            console.log("使用原文标题构建预览URL:", previewSrc);
                                                        } else if (currentEditorMode === 'create' && currentEditorSessionId) {
                                                            // 创建模式，图片不是当前会话粘贴的 (理论上不太可能，除非粘贴后记录失败)
                                                            // 或者编辑模式但无法获取原始标题 (异常情况) -> 尝试用当前会话ID
                                                            previewSrc = `${baseUrlForAssets}/temp_assets/${currentEditorSessionId}/assets/${imageName}`;
                                                            console.log("创建模式或编辑模式无原文标题，尝试用会话ID构建预览URL:", previewSrc);
                                                        } else {
                                                            console.warn(`无法确定预览路径: ${href}.模式: ${currentEditorMode}, 会话ID: ${currentEditorSessionId}, 原标题: ${originalPostTitleInput ? originalPostTitleInput.value : 'N/A'}`);
                                                            return `<img src="" alt="${text}" title="预览不可 (路径解析失败)" class="max-w-full h-auto my-4 p-4 border border-dashed rounded text-center text-gray-500">`;
                                                        }
                                                        
                                                        previewSrc += `?t=${new Date().getTime()}`; // Cache buster
                                                        return `<img src="${previewSrc}" alt="${text}"${title ? ` title="${title}"` : ''} class="max-w-full h-auto my-4 rounded shadow">`;
                                                    
                                                    } else if (href.startsWith('/temp_assets/') || href.startsWith('/blog_assets/')) {
                                                        let fullHref = href;
                                                        if (!href.startsWith(baseUrlForAssets)) {
                                                            fullHref = baseUrlForAssets + href;
                                                        }
                                                        fullHref += `?t=${new Date().getTime()}`;
                                                        return `<img src="${fullHref}" alt="${text}"${title ? ` title="${title}"` : ''} class="max-w-full h-auto my-4 rounded shadow">`;
                                                    }
                                                    
                                                    // For external images or other paths, use default behavior
                                                    // or handle them as absolute URLs if they are (e.g. http://, https://)
                                                    if (href.match(/^https?:\/\//i)) {
                                                         return originalImageRenderer.call(renderer, href, title, text);
                                                    }
                                                    // If it's some other kind of relative path not starting with ./assets, it might be broken for preview
                                                    // or meant for a different context. Default renderer might show broken link.
                                                    return originalImageRenderer.call(renderer, href, title, text);
                                                };

                                                renderer.text = function(text) {
                                                    // ... existing code ...
                                                };

                                                marked.setOptions({
                                                    renderer: renderer,
                                                    gfm: true,
                                                    breaks: true,
                                                    sanitize: false,
                                                    smartLists: true,
                                                    smartypants: false
                                                });
                                            } else {
                                                console.error("Marked库未加载");
                                            }
                                        }

                                        async function loadBlogLabelFilterCategories() {
                                            const categories = await fetchData('/labels'); // Fetches {name, color}
                                            if (blogLabelFilterElement) { // Use the correctly initialized variable
                                                if (categories && categories.length > 0) {
                                                    let optionsHTML = '<option value="all">すべて</option>'; // Keep "All" option
                                                    optionsHTML += categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
                                                    blogLabelFilterElement.innerHTML = optionsHTML;
                                                } else {
                                                    blogLabelFilterElement.innerHTML = '<option value="all">すべて</option><option value="">カテゴリなし</option>';
                                                }
                                            } else {
                                                console.warn("blogLabelFilterElement not found.");
                                            }
                                        }
                                        loadBlogLabelFilterCategories();
                                        // NEW FUNCTION: Initialize EasyMDE
                                        function initializeEasyMDE(initialValue = '') {
                                            const editorTextarea = document.getElementById('blog-content-editor');
                                            if (!editorTextarea) {
                                                console.error("Textarea #blog-content-editor not found for EasyMDE.");
                                                return null;
                                            }
                                            
                                            configureMarkedGlobally({ 
                                                postTitle: (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) 
                                                            ? originalPostTitleInput.value 
                                                            : null 
                                            });

                                            const instance = new EasyMDE({
                                                element: editorTextarea,
                                                initialValue: initialValue,
                                                spellChecker: false,
                                                autoDownloadFontAwesome: true, 
                                                minHeight: "400px", 
                                                maxHeight: "70vh",
                                                theme: "inner", // This will make CodeMirror use .cm-s-inner class from your purple-cesno.css
                                                toolbar: [
                                                    "bold", "italic", "strikethrough", "heading", "|", 
                                                    "quote", "unordered-list", "ordered-list", 
                                                    { 
                                                        name: "codeblock",
                                                        action: EasyMDE.drawCode, 
                                                        className: "fa fa-code",
                                                        title: "コードブロック",
                                                    },
                                                    "|",
                                                    "link", 
                                                    { 
                                                        name: "customImage",
                                                        action: function customImage(editor){
                                                            alert("画像をエディタにドラッグアンドドロップするか、貼り付けてください。");
                                                        },
                                                        className: "fa fa-image", 
                                                        title: "画像 (ドラッグ&ドロップまたは貼り付け)",
                                                    },
                                                    "table", "|", 
                                                    "preview", "side-by-side", "fullscreen", "|", // MODIFIED: Restored standard side-by-side
                                                    "guide",
                                                    {
                                                        name: "imageZoom",
                                                        action: function customImageZoom(editor) {
                                                            showImageZoomPanel(editor);
                                                        },
                                                        className: "fa fa-search-plus", // 你可以用 FontAwesome 的放大镜图标
                                                        title: "图片缩放"
                                                    },
                                                    "image", // 原生图片插入
                                                    {
                                                        name: "insertImageUpload",
                                                        action: function(editor) {
                                                            openImageFileDialogAndInsert(editor);
                                                        },
                                                        className: "fa fa-upload", // 你可以用 FontAwesome 的上传图标
                                                        title: "本地图片插入"
                                                    },
                                                ],
                                                uploadImage: true, 
                                                imageUploadFunction: async (file, onSuccess, onError) => {
                                                    if (!window.currentEditorSessionId) {
                                                        window.currentEditorSessionId = `session_${new Date().getTime()}_${Math.random().toString(36).substring(2, 10)}`;
                                                        console.warn("EasyMDE imageUpload: currentEditorSessionId was not set, generated new one:", window.currentEditorSessionId);
                                                    }

                                                    const formData = new FormData();
                                                    formData.append('image_file', file, file.name || 'pasted_image.png');
                                                    formData.append('session_id', window.currentEditorSessionId);
                                                    // MODIFIED: Add edit mode context
                                                    if (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) {
                                                        formData.append('is_editing', 'true');
                                                        // MODIFIED: Send the value from originalPostTitleInput as the post identifier
                                                        formData.append('original_post_title', originalPostTitleInput.value); 
                                                    } else {
                                                        formData.append('is_editing', 'false');
                                                    }

                                                    try {
                                                        const response = await fetch(`${API_BASE_URL}/paste_image`, {
                                                            method: 'POST',
                                                            body: formData
                                                        });
                                                        const result = await response.json();
                                                        if (response.ok && result.filePath && result.filenameInAssets) {
                                                            // filePath 已经是 ./assets/image_X.ext 格式
                                                            onSuccess(result.filePath); 
                                                            
                                                            if (!window.currentSessionPastedAssets) window.currentSessionPastedAssets = [];
                                                            window.currentSessionPastedAssets = window.currentSessionPastedAssets.filter(asset => asset.markdownPath !== result.filePath);
                                                            window.currentSessionPastedAssets.push({ 
                                                                markdownPath: result.filePath, // This is like ./assets/image_X.png
                                                                previewUrl: result.previewUrl   // This is like /temp_assets/session_id/assets/image_X.png
                                                            });
                                                            console.log("EasyMDE Image Upload Success. Editor gets:", result.filePath, "Preview via:", result.previewUrl);
                                                        } else {
                                                            console.error("EasyMDE Image Upload Error from server:", result.error);
                                                            onError(`画像アップロードエラー: ${result.error || '不明なエラー'}`);
                                                        }
                                                    } catch (error) {
                                                        console.error("EasyMDE Image Upload Network Error:", error);
                                                        onError(`ネットワークエラー: ${error.toString()}`);
                                                    }
                                                },
                                                previewRender: function(plainText, preview) { 
                                                    // Re-configure marked with current editor context before parsing for preview
                                                    configureMarkedGlobally({ 
                                                        postTitle: (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) 
                                                                    ? originalPostTitleInput.value 
                                                                    : null 
                                                    });

                                                    const html = marked.parse(plainText); // marked uses the globally configured options
                                                    preview.innerHTML = html; 

                                                    // Apply syntax highlighting to code blocks in the preview
                                                    if (typeof hljs !== 'undefined') {
                                                        preview.querySelectorAll('pre code').forEach(block => {
                                                            hljs.highlightElement(block);
                                                        });
                                                    }

                                                    // Apply KaTeX rendering
                                                    if (typeof renderMathInElement === 'function') {
                                                        try {
                                                            renderMathInElement(preview, {
                                                                delimiters: [
                                                                    {left: "$$", right: "$$", display: true},
                                                                    {left: "$", right: "$", display: false}
                                                                ],
                                                                throwOnError: false,
                                                                errorColor: '#cc0000'
                                                            });
                                                        } catch (katexError) {
                                                            console.error("EasyMDE preview KaTeX rendering error:", katexError);
                                                        }
                                                    }
                                                    return preview.innerHTML; 
                                                },
                                            });

                                            if (instance) { 
                                                setTimeout(() => {
                                                    if (!instance.isSideBySideActive()) {
                                                         instance.toggleSideBySide();
                                                    }
                                                    // The fullscreen decoupling is very hard with EasyMDE's default.
                                                    // The CSS attempts are the primary way for now.
                                                }, 200); 
                                            }

                                            // Handle KaTeX rendering on CodeMirror changes for side-by-side
                                            if (instance && instance.codemirror) {
                                                instance.codemirror.on("change", debounce(() => {
                                                    if (instance.isPreviewActive() || instance.isSideBySideActive()) {
                                                        // EasyMDE automatically updates its preview.
                                                        // The previewRender function handles KaTeX.
                                                        // If direct re-triggering on the preview DOM is needed:
                                                        const previewPanel = instance.gui.preview;
                                                        if (previewPanel && typeof renderMathInElement === 'function') {
                                                            setTimeout(() => { // Ensure DOM update from EasyMDE first
                                                                try {
                                                                    renderMathInElement(previewPanel, {
                                                                        delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ],
                                                                        throwOnError: false, errorColor: '#cc0000'
                                                                    });
                                                                } catch (e) { console.error("KaTeX error on EasyMDE CM change:", e); }
                                                            }, 50); // Small delay
                                                        }
                                                    }
                                                }, 300));
                                            }
                                            return instance;
                                        }

                                        // NEW: Function to get a configured marked renderer based on context
                                        function getCustomMarkedRenderer(options = {}) {
                                            const renderer = new marked.Renderer();
                                            const originalImageRenderer = renderer.image;

                                            renderer.image = function(href, title, text) {
                                                console.log("Custom Marked Renderer - Image:", { href, title, text, type: typeof href, options });

                                                let styleAttribute = "";
                                                let originalHrefForResolution = href; // Store the original href

                                                // 检查 href 是否为字符串以及是否包含 #zoom=
                                                if (href && typeof href === 'string') {
                                                    const hashIndex = href.indexOf('#zoom=');
                                                    if (hashIndex !== -1) {
                                                        const zoomValueString = href.substring(hashIndex + '#zoom='.length);
                                                        const zoomDigits = zoomValueString.match(/^\d+/); // 只提取数字部分
                                                        if (zoomDigits) {
                                                            const zoomValue = parseInt(zoomDigits[0], 10);
                                                            if (!isNaN(zoomValue)) {
                                                                styleAttribute = `zoom:${zoomValue}%;`;
                                                            }
                                                        }
                                                        originalHrefForResolution = href.substring(0, hashIndex); // 更新 href 为不包含 #zoom 的部分
                                                    }
                                                }
                                                
                                                // --- href type checks and object handling (使用 originalHrefForResolution) ---
                                                if (originalHrefForResolution && typeof originalHrefForResolution === 'object') {
                                                    if (originalHrefForResolution.href) {
                                                        // Create a new object for recursion to avoid modifying the original 'href' object if it's reused
                                                        const newHrefObject = { ...originalHrefForResolution };
                                                        // If styleAttribute was already parsed from the outer href object's hash,
                                                        // we should ensure it's not lost or re-evaluated incorrectly.
                                                        // For now, this recursive call assumes the inner href.href is clean.
                                                        // If the object itself could have a #zoom, logic might need to be more complex.
                                                        return renderer.image(newHrefObject.href, newHrefObject.title || title, newHrefObject.text || text);
                                                    } else {
                                                        console.warn("Renderer: href is object but no href.href property:", originalHrefForResolution);
                                                        return `<img src="" alt="无效图片对象" class="border border-red-500 p-2">`;
                                                    }
                                                }

                                                if (!originalHrefForResolution || typeof originalHrefForResolution !== 'string') {
                                                    console.warn('Renderer: Invalid image href value (after initial processing):', originalHrefForResolution);
                                                    return `<img src="" alt="${text || '图片加载失败'}" title="无效的图片链接" class="max-w-full h-auto my-4 border border-red-300 p-2 text-center text-red-500">`;
                                                }
                                                // --- End of href type checks ---

                                                const baseUrlForAssets = API_BASE_URL.replace('/api', ''); 
                                                let resolvedSrc = originalHrefForResolution;

                                                if (originalHrefForResolution.startsWith('./assets/')) {
                                                    let previewSrc = "";
                                                    const imageName = originalHrefForResolution.substring('./assets/'.length);
                                                    let imageContext = "unknown_relative_asset";

                                                    if (window.currentEditorSessionId && window.currentSessionPastedAssets) {
                                                        const pastedAssetInfo = window.currentSessionPastedAssets.find(p => p.markdownPath === originalHrefForResolution); 
                                                        if (pastedAssetInfo && pastedAssetInfo.previewUrl) {
                                                            previewSrc = pastedAssetInfo.previewUrl;
                                                            if (!previewSrc.startsWith(baseUrlForAssets) && previewSrc.startsWith('/')) {
                                                                previewSrc = baseUrlForAssets + previewSrc;
                                                            }
                                                            imageContext = "current_session_pasted";
                                                        }
                                                    }

                                                    if (!previewSrc) {
                                                        let postIdentifierForPath = null;
                                                        if (options.postTitle) { 
                                                            postIdentifierForPath = options.postTitle;
                                                            imageContext = "full_post_view_existing_asset";
                                                        } else if (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) { 
                                                            postIdentifierForPath = originalPostTitleInput.value;
                                                            imageContext = "editor_edit_mode_existing_asset";
                                                        }

                                                        if (postIdentifierForPath) {
                                                            previewSrc = `${baseUrlForAssets}/blog_assets/${encodeURIComponent(postIdentifierForPath)}/assets/${imageName}`;
                                                        }
                                                    }
                                                    
                                                    if (!previewSrc && window.currentEditorSessionId && (currentEditorMode === 'create' || !originalPostTitleInput || !originalPostTitleInput.value)) {
                                                         previewSrc = `${baseUrlForAssets}/temp_assets/${window.currentEditorSessionId}/assets/${imageName}`;
                                                         imageContext = "editor_temp_session_asset";
                                                    }

                                                    if (previewSrc) {
                                                        resolvedSrc = previewSrc;
                                                    } else {
                                                        resolvedSrc = originalHrefForResolution; 
                                                    }
                                                } else if (originalHrefForResolution.startsWith('/temp_assets/') || originalHrefForResolution.startsWith('/blog_assets/')) {
                                                    if (!originalHrefForResolution.startsWith(baseUrlForAssets)) {
                                                        resolvedSrc = baseUrlForAssets + originalHrefForResolution;
                                                    }
                                                } else if (originalHrefForResolution.match(/^https?:\/\//i)) {
                                                    resolvedSrc = originalHrefForResolution; 
                                                } else {
                                                     resolvedSrc = originalHrefForResolution; 
                                                }

                                                resolvedSrc += `${resolvedSrc.includes('?') ? '&' : '?'}t=${new Date().getTime()}`;
                                                
                                                let imgTag = `<img src="${resolvedSrc}" alt="${text || ''}"`;
                                                if (title) {
                                                    imgTag += ` title="${title}"`;
                                                }
                                                imgTag += ` class="max-w-full h-auto my-4 rounded shadow"`;
                                                if (styleAttribute) { // 应用解析出的 styleAttribute
                                                    imgTag += ` style="${styleAttribute}"`;
                                                }
                                                imgTag += `>`;
                                                
                                                return imgTag;
                                            };
                                            // Add other renderer customizations here if needed (e.g., for links, code, etc.)
                                            return renderer;
                                        }

                                        // NEW: Function to configure marked.js globally with a specific renderer
                                        function configureMarkedGlobally(options = {}) {
                                            if (typeof marked === 'undefined') {
                                                console.error("Marked library not loaded.");
                                                return;
                                            }
                                            const customRenderer = getCustomMarkedRenderer(options); // Get renderer with context

                                            marked.setOptions({
                                                renderer: customRenderer,
                                                highlight: function(code, lang) {
                                                    if (typeof hljs === 'undefined') return code;
                                                    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                                                    try {
                                                        return hljs.highlight(code, { language, ignoreIllegals: true }).value;
                                                    } catch (e) {
                                                        console.error("Highlight.js error:", e, "lang:", lang, "code:", code.substring(0,50));
                                                        return hljs.highlight(code, { language: 'plaintext', ignoreIllegals: true }).value; // fallback
                                                    }
                                                },
                                                gfm: true,
                                                breaks: true,
                                                sanitize: false,
                                                smartLists: true,
                                                smartypants: false
                                            });
                                            console.log("Marked.js configured globally with options:", options);
                                        }

                                        async function loadPostDetail(postSlug) {
                                            showView('post-detail');
                                            const postDetailContentContainer = document.getElementById('post-detail-content-container');
                                            if (postDetailContentContainer) postDetailContentContainer.innerHTML = '<p>投稿を読み込み中...</p>';

                                            const post = await fetchData(`/post/${decodeURIComponent(postSlug)}`);

                                            if (post && !post.error) {
                                                // Configure marked with the context of THIS post's title before parsing
                                                configureMarkedGlobally({ postTitle: post.title });

                                                const htmlContent = marked.parse(post.content_md || '');
                                                
                                                const postDetailTitleEl = document.getElementById('post-detail-title');
                                                const postDetailDateEl = document.getElementById('post-detail-date');
                                                const postDetailCategoryEl = document.getElementById('post-detail-category');
                                                const postDetailTagsEl = document.getElementById('post-detail-tags'); // Ensure this element exists for tags

                                                if(postDetailTitleEl) postDetailTitleEl.textContent = post.title;
                                                if(postDetailDateEl) postDetailDateEl.textContent = post.date;
                                                if(postDetailCategoryEl) postDetailCategoryEl.textContent = post.category;
                                                
                                                if(postDetailContentContainer) postDetailContentContainer.innerHTML = htmlContent;

                                                if(postDetailTagsEl && post.tags && post.tags.length > 0) {
                                                    postDetailTagsEl.innerHTML = `<span class="font-semibold mr-2">タグ:</span>` + post.tags.map(tag => `<span class="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-xs mr-1 mb-1 inline-block">${tag}</span>`).join('');
                                                } else if (postDetailTagsEl) {
                                                    postDetailTagsEl.innerHTML = ''; // Clear if no tags
                                                }

                                                // Apply KaTeX and Highlight.js to the newly rendered content
                                                if (typeof renderMathInElement === 'function' && postDetailContentContainer) {
                                                    renderMathInElement(postDetailContentContainer, {
                                                        delimiters: [
                                                            {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}
                                                        ],
                                                        throwOnError: false, errorColor: '#cc0000'
                                                    });
                                                }
                                                if (typeof hljs !== 'undefined' && postDetailContentContainer) {
                                                    postDetailContentContainer.querySelectorAll('pre code').forEach(block => {
                                                        hljs.highlightElement(block);
                                                    });
                                                }
                                            } else {
                                                if (postDetailContentContainer) postDetailContentContainer.innerHTML = `<p class="text-red-500">投稿「${decodeURIComponent(postSlug)}」の読み込みに失敗しました: ${post ? post.error : '不明なエラー'}</p>`;
                                            }
                                        }

                                        function showImageZoomPanel(editor) {
                                            const cm = editor.codemirror;
                                            const pos = cm.getCursor();
                                            const line = cm.getLine(pos.line);
                                            // 更新正则表达式以匹配新的 #zoom=XX 格式（如果已存在）或旧的 {style...} 格式，主要用于读取当前值
                                            const imgMdRegex = /!\[(.*?)\]\((.*?)(?:#zoom=(\d+)|(?:\{style="zoom:(\d+)%;"\}))?\)/g;
                                            let match;
                                            
                                            // 从光标位置向后和向前搜索，确保在图片Markdown内部
                                            // 简单的行匹配可能不够鲁棒，但对于多数情况应该可以
                                            imgMdRegex.lastIndex = 0; // Reset regex state
                                            let foundMatch = null;
                                            while ((match = imgMdRegex.exec(line)) !== null) {
                                                if (pos.ch >= match.index && pos.ch <= match.index + match[0].length) {
                                                    foundMatch = match;
                                                    break;
                                                }
                                            }

                                            if (foundMatch) {
                                                match = foundMatch; // 使用找到的匹配项
                                                let altText = match[1];
                                                let url = match[2];
                                                let currentZoom = 100; // 默认值
                                                if (match[3]) { // 匹配 #zoom=XX
                                                    currentZoom = parseInt(match[3]);
                                                } else if (match[4]) { // 匹配 {style="zoom:XX%;"}
                                                    currentZoom = parseInt(match[4]);
                                                }
                                                    
                                                let newZoomInput = prompt("请输入缩放百分比（例如 80 表示80%）:", currentZoom);
                                                if (newZoomInput && !isNaN(newZoomInput)) {
                                                    const newZoom = Math.max(10, Math.min(500, parseInt(newZoomInput)));
                                                        
                                                    // 确保基础 URL 不包含旧的 #zoom 片段或 {style}
                                                    let baseUrl = url.split('#zoom=')[0]; // 移除 #zoom
                                                    // 如果旧格式是 {style...}, url 通常是干净的，但为了保险可以进一步处理
                                                    // baseUrl = baseUrl.replace(/\{style="zoom:\d+%;"\}/g, ''); // 这可能不是必需的，因为 {style...} 通常在 match[0] 而不是 match[2]

                                                    const newMd = `![${altText}](${baseUrl}#zoom=${newZoom})`; 
                                                        
                                                    cm.replaceRange(newMd, 
                                                        {line: pos.line, ch: match.index}, 
                                                        {line: pos.line, ch: match.index + match[0].length});
                                                }
                                            } else {
                                                alert("请将光标置于图片链接内部再使用缩放功能。");
                                            }
                                        }

                                        function openImageFileDialogAndInsert(editor) {
                                            let input = document.createElement('input');
                                            input.type = 'file';
                                            input.accept = 'image/*';
                                            input.style.display = 'none';
                                            document.body.appendChild(input);

                                            input.onchange = async function() {
                                                const file = input.files[0];
                                                if (!file) return;
                                                
                                                const formData = new FormData();
                                                formData.append('image_file', file, file.name || 'uploaded_image.png');
                                                formData.append('session_id', window.currentEditorSessionId);
                                                // MODIFIED: Add edit mode context
                                                if (currentEditorMode === 'edit' && originalPostTitleInput && originalPostTitleInput.value) {
                                                    formData.append('is_editing', 'true');
                                                    formData.append('original_post_title', originalPostTitleInput.value);
                                                } else {
                                                    formData.append('is_editing', 'false');
                                                }

                                                try {
                                                    const response = await fetch(`${API_BASE_URL}/paste_image`, {
                                                        method: 'POST',
                                                        body: formData
                                                    });
                                                    const result = await response.json();
                                                    if (response.ok && result.filePath && result.filenameInAssets) {
                                                        const cm = editor.codemirror;
                                                        const pos = cm.getCursor();
                                                        // filePath 已经是 ./assets/image_X.ext 格式
                                                        const md = `![${file.name}](${result.filePath})`; 
                                                        cm.replaceRange(md, pos);
                                                        
                                                        if (!window.currentSessionPastedAssets) window.currentSessionPastedAssets = [];
                                                        window.currentSessionPastedAssets = window.currentSessionPastedAssets.filter(asset => asset.markdownPath !== result.filePath);
                                                        window.currentSessionPastedAssets.push({ 
                                                            markdownPath: result.filePath, 
                                                            previewUrl: result.previewUrl 
                                                        });
                                                         console.log("Manual Image Upload Success. Editor gets:", result.filePath, "Preview via:", result.previewUrl);
                                                    } else {
                                                        alert("图片上传失败: " + (result.error || "未知错误"));
                                                    }
                                                } catch (e) {
                                                    alert("图片上传异常: " + e);
                                                }
                                                document.body.removeChild(input);
                                            };
                                            input.click();
                                        }

                                        function editorCtrlSHandler(event) {
                                            // MODIFIED: Changed to Ctrl+Alt+S or Cmd+Alt+S
                                            if ((event.ctrlKey || event.metaKey) && event.altKey && event.key === 's') {
                                                event.preventDefault();
                                                console.log("Ctrl+Alt+S 检测到，执行保存。");
                                                handleSavePost({ showSuccessAlert: true }); 
                                            }
                                        }

                                        function setupCtrlSListener() {
                                            // 确保只在 EasyMDE 的 CodeMirror 实例上附加一次事件
                                            if (easymde && easymde.codemirror && !easymde.codemirror._ctrlAltSAttached) { // MODIFIED: Changed flag name
                                                easymde.codemirror.on('keydown', editorCtrlSHandler);
                                                easymde.codemirror._ctrlAltSAttached = true;  // MODIFIED: Changed flag name
                                                console.log("Ctrl+Alt+S 监听器已设置 (编辑器)。");
                                            }
                                            // 也为标题等输入框设置
                                            const inputsToWatch = [blogTitleEditor, blogTagsEditor, blogCategoryEditor, blogDateEditor];
                                            inputsToWatch.forEach(input => {
                                                if (input && !input._ctrlAltSAttached) { // MODIFIED: Changed flag name
                                                    input.addEventListener('keydown', editorCtrlSHandler);
                                                    input._ctrlAltSAttached = true; // MODIFIED: Changed flag name
                                                }
                                            });
                                            console.log("Ctrl+Alt+S 监听器已设置 (输入框)。");
                                        }
                                        
                                        function removeCtrlSListener() {
                                            if (easymde && easymde.codemirror && easymde.codemirror._ctrlAltSAttached) { // MODIFIED: Changed flag name
                                                easymde.codemirror.off('keydown', editorCtrlSHandler);
                                                delete easymde.codemirror._ctrlAltSAttached; // MODIFIED: Changed flag name
                                                console.log("编辑器 Ctrl+Alt+S 监听器已移除。");
                                            }
                                             const inputsToWatch = [blogTitleEditor, blogTagsEditor, blogCategoryEditor, blogDateEditor];
                                            inputsToWatch.forEach(input => {
                                                if (input && input._ctrlAltSAttached) { // MODIFIED: Changed flag name
                                                    input.removeEventListener('keydown', editorCtrlSHandler);
                                                    delete input._ctrlAltSAttached; // MODIFIED: Changed flag name
                                                }
                                            });
                                            console.log("输入框 Ctrl+Alt+S 监听器已移除。");
                                        }

                                        let contributionGraphActivity, contributionGraphFrequency; // Declare globally or within DOMContentLoaded


                                        async function setupContributionGraph() {
                                            // MODIFIED: Use the specific graph containers
                                            const activityGraphContainer = document.getElementById('contribution-graph-activity');
                                            const frequencyGraphContainer = document.getElementById('contribution-graph-frequency');

                                            if (!activityGraphContainer || !frequencyGraphContainer) {
                                                console.warn("一个或两个贡献图容器未找到。");
                                                return;
                                            }

                                            try {
                                                // MODIFIED: Fetch data from the new API endpoint
                                                const response = await fetch(`${API_BASE_URL}/contribution-data`);
                                                if (!response.ok) {
                                                    throw new Error(`HTTP error! status: ${response.status}`);
                                                }
                                                const data = await response.json(); // Expecting JSON array of [activity_count, frequency_count] pairs

                                                // Check if data is in the expected format and length
                                                if (!Array.isArray(data) || data.length < 365 || (data.length > 0 && (!Array.isArray(data[0]) || data[0].length !== 2))) {
                                                     console.error("从后端获取的贡献数据格式不正确或数据不足:", data);
                                                     activityGraphContainer.innerHTML = "<p class='text-red-500 text-center'>活动数据加载失败 (格式错误)</p>";
                                                     frequencyGraphContainer.innerHTML = "<p class='text-red-500 text-center'>编辑频次数据加载失败 (格式错误)</p>";
                                                     return;
                                                }
                                                
                                                const activityData = data.map(day => day[0]); // Extract activity counts
                                                const frequencyData = data.map(day => day[1]); // Extract frequency counts
                                                
                                                console.log("DEBUG: Contribution Data (Activity) fetched:", activityData); // Log to console
                                                console.log("DEBUG: Contribution Data (Frequency) fetched:", frequencyData); // Log to console


                                                // MODIFIED: Render the two graphs separately
                                                // Determine max values for leveling based on actual data or a reasonable cap
                                                // We can use hardcoded max levels (e.g., 5 for activity, 30 for frequency as in mock)
                                                // or scale based on actual max values. Let's use hardcoded for consistency with visual design.
                                                renderGraph(activityGraphContainer, activityData, 5); // 假设活动量最高不超过5
                                                renderGraph(frequencyGraphContainer, frequencyData, 30); // 假设编辑频次最高不超过30

                                            } catch (error) {
                                                console.error("无法加载或解析贡献数据:", error);
                                                if(activityGraphContainer) activityGraphContainer.innerHTML = "<p class='text-red-500 text-center'>活动数据加载失败</p>";
                                                if(frequencyGraphContainer) frequencyGraphContainer.innerHTML = "<p class='text-red-500 text-center'>编辑频次数据加载失败</p>";
                                            }
                                        }

                                        function renderGraph(container, data, maxValueForLeveling) {
                                            container.innerHTML = ''; // 清空
                                            const daysInYear = 365; // 总共显示的天数
                                            // MODIFIED: Calculate cells to display to align with the start of the year for GitHub-like graph
                                            // Get today's date and the date 364 days ago
                                            const today = new Date();
                                            today.setHours(0, 0, 0, 0); // Reset time to compare dates only

                                            const dataEndDate = new Date(today); // Data ends today

                                            const dataStartDate = new Date(today);
                                            dataStartDate.setDate(today.getDate() - 364); // Data starts 364 days ago (total 365 days)
                                            dataStartDate.setHours(0, 0, 0, 0);

                                            // Determine the start date of the week containing the overall graph start date
                                            // The graph should start on the Sunday of the week that contains the first data point (or slightly before)
                                            const graphStartDate = new Date(dataStartDate);
                                            const startDayOfWeek = graphStartDate.getDay(); // 0 for Sunday, 6 for Saturday
                                            graphStartDate.setDate(dataStartDate.getDate() - startDayOfWeek);
                                            graphStartDate.setHours(0, 0, 0, 0);

                                            // Determine the end date of the week containing today
                                            const graphEndDate = new Date(today);
                                            const endDayOfWeek = graphEndDate.getDay();
                                            graphEndDate.setDate(today.getDate() + (6 - endDayOfWeek)); // Go to the following Saturday
                                            graphEndDate.setHours(0, 0, 0, 0);


                                            const totalCells = Math.ceil((graphEndDate - graphStartDate) / (1000 * 60 * 60 * 24)) + 1;
                                            const cellsToDisplay = totalCells; 

                                            const monthNames = ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"];

                                            // Create cells
                                            for (let i = 0; i < cellsToDisplay; i++) {
                                                const cellDate = new Date(graphStartDate);
                                                cellDate.setDate(graphStartDate.getDate() + i);
                                                cellDate.setHours(0, 0, 0, 0); // Reset time

                                                const dateStr = cellDate.toISOString().split('T')[0];
                                                
                                                // Find the corresponding data point.
                                                // The `data` array is expected to be 365 days, ordered chronologically from 364 days ago to today.
                                                // Calculate the index relative to the *start date of the data* (dataStartDate)
                                                const dataIndex = Math.floor((cellDate.getTime() - dataStartDate.getTime()) / (1000 * 60 * 60 * 24));

                                                let value = 0;
                                                // Only get data if the cellDate is within the 365-day data range (from dataStartDate to dataEndDate)
                                                if (cellDate >= dataStartDate && cellDate <= dataEndDate) {
                                                     if (dataIndex >= 0 && dataIndex < data.length) {
                                                        value = data[dataIndex];
                                                    }
                                                }


                                                let level = 0;
                                                if (value > 0) {
                                                    // Scale levels based on maxValueForLeveling
                                                    const step = maxValueForLeveling / 4.0; // Divide the range > 0 into 4 levels
                                                    if (value > step * 3) level = 4;
                                                    else if (value > step * 2) level = 3;
                                                    else if (value > step) level = 2;
                                                    else level = 1; // Any value > 0 is at least level 1
                                                }
                                                // If value is 0, level remains 0

                                                const cell = document.createElement('div');
                                                cell.className = `contribution-cell level-${level}`;
                                                cell.setAttribute('data-date', dateStr);
                                                cell.setAttribute('title', `${dateStr}: ${value}`);
                                                
                                                // Handle future dates (dates after today) - make them level 0 and update tooltip
                                                if (cellDate > today) {
                                                    cell.classList.remove(`level-${level}`); // Remove potential level class
                                                    cell.classList.add('level-0'); // Ensure level 0 color
                                                    cell.setAttribute('title', `${dateStr}: 未来`);
                                                }


                                                container.appendChild(cell);

                                                // Month labels - needs careful positioning based on column flow
                                                // This is complex with grid-flow-col and dynamic cell counts.
                                                // A simplified approach is to add a separate div for months above the graph.
                                            }
                                            
                                            // Add month labels above the grid (requires restructuring or careful positioning)
                                            // For simplicity in this edit, we won't add month labels directly within the grid container.
                                            // The tooltip on hover provides the date.
                                        }

                                        // Add a function to load categories for the blog filter dropdown
                                        async function loadBlogLabelFilterCategories() {
                                            const categories = await fetchData('/labels'); // Fetches {name, color}
                                            if (blogLabelFilterElement) { // Use the correctly initialized variable
                                                if (categories && categories.length > 0) {
                                                    let optionsHTML = '<option value="all">すべて</option>'; // Keep "All" option
                                                    optionsHTML += categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
                                                    blogLabelFilterElement.innerHTML = optionsHTML;
                                                } else {
                                                    blogLabelFilterElement.innerHTML = '<option value="all">すべて</option><option value="">カテゴリなし</option>';
                                                }
                                            } else {
                                                console.warn("blogLabelFilterElement not found.");
                                            }
                                        }
                                        // Call this function on DOMContentLoaded
                                        // ... inside DOMContentLoaded ...
                                        loadBlogLabelFilterCategories(); // Add this call
                                        // ...

                                        async function loadDocuments() {
                                            console.log('[DEBUG Frontend] loadDocuments called.');
                                            if (!documentListContainer) {
                                                console.error("[DEBUG Frontend] Document list container not found.");
                                                return;
                                            }
                                            documentListContainer.innerHTML = '<p class="text-center text-gray-500 py-8">ドキュメントを読み込み中...</p>'; // Show loading

                                            try {
                                                console.log('[DEBUG Frontend] Fetching documents from /api/documents...');
                                                const documents = await fetchData('/documents'); // Assume /api/documents endpoint exists

                                                console.log('[DEBUG Frontend] Received documents data:', documents);

                                                // MODIFIED: Store fetched data and apply filters/sort
                                                if (documents && Array.isArray(documents)) {
                                                     console.log(`[DEBUG Frontend] Found ${documents.length} documents. Storing and applying filters...`);
                                                    // Store the original fetched data for filtering/sorting
                                                    window.allFetchedDocuments = documents;
                                                    // Initially apply filters/sort (will render the list)
                                                     applyDocumentFiltersAndSort(); // This will call renderDocumentList

                                                } else {
                                                     console.log('[DEBUG Frontend] No documents received or data is not an array:', documents);
                                                    documentListContainer.innerHTML = '<p class="text-center text-gray-500 py-8">ドキュメントはありません。</p>';
                                                }
                                            } catch (error) {
                                                console.error('[DEBUG Frontend] ドキュメントの読み込みに失敗しました:', error);
                                                documentListContainer.innerHTML = '<p class="text-center text-red-500 py-8">ドキュメントの読み込み中にエラーが発生しました。</p>';
                                            }
                                        }

                                        // NEW FUNCTION: Render the document list items
                                        function renderDocumentList(documentsToRender) {
                                            console.log('[DEBUG Frontend] renderDocumentList called with', documentsToRender.length, 'documents.');
                                            if (!documentListContainer) return;

                                            if (documentsToRender.length === 0) {
                                                documentListContainer.innerHTML = '<p class="text-center text-gray-500 py-8">選択された条件に一致するドキュメントはありません。</p>';
                                                return;
                                            }

                                            const documentItemsHtml = documentsToRender.map(doc => {
                                                const docName = doc.name ? String(doc.name) : '無名のファイル';
                                                const docPath = doc.path ? String(doc.path) : '';
                                                const docType = doc.type ? String(doc.type) : '不明';
                                                const lastModified = doc.last_modified ? new Date(doc.last_modified).toLocaleDateString('ja-JP') : '日付不明';
                                                const docUrl = doc.url; // URL from backend
                                                const fullDownloadUrl = `${API_BASE_URL.replace('/api', '')}${docUrl}`;

                                                return `
                                                    <div class="document-item flex items-center justify-between border-b border-gray-200 py-3 px-2 hover:bg-gray-50 transition-colors duration-150">
                                                        <div class="flex items-center flex-grow min-w-0 mr-3 cursor-pointer" data-doc-path="${encodeURIComponent(docPath)}"> 
                                                            <div class="mr-3 text-gray-500 text-xl"> 
                                                                ${docType === 'PDF' ?
                                                                    '<i class="far fa-file-pdf"></i>' :
                                                                    '<i class="far fa-file"></i>'
                                                                }
                                                            </div>
                                                            <div class="flex-grow min-w-0"> 
                                                                <h4 class="text-md font-semibold text-gray-700 truncate" title="${docName}">${docName}</h4> 
                                                                <p class="text-xs text-gray-500">${lastModified}</p>
                                                            </div>
                                                        </div>
                                                        <div class="flex-shrink-0 ml-auto"> 
                                                            <a href="${fullDownloadUrl}" download="${docName}" 
                                                               class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-xs font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors"
                                                               title="ダウンロード ${docName}">
                                                                ダウンロード
                                                            </a>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('');

                                            documentListContainer.innerHTML = documentItemsHtml;

                                            // Add event listeners using delegation on the container for item clicks (not download button)
                                            documentListContainer.removeEventListener('click', handleDocumentItemClick);
                                            documentListContainer.addEventListener('click', handleDocumentItemClick);
                                        }

                                        // NEW FUNCTION: Handle click on a document item
                                        function handleDocumentItemClick(event) {
                                            // Check if the click was on the download button or its children. If so, do nothing and let the link work.
                                            if (event.target.closest('a[download]')) {
                                                console.log('[DEBUG Frontend] Download button clicked, allowing default action.');
                                                return;
                                            }

                                            const documentItemDiv = event.target.closest('.document-item > div[data-doc-path]'); // Target the specific clickable div
                                            if (documentItemDiv) {
                                                const docPath = decodeURIComponent(documentItemDiv.dataset.docPath);
                                                console.log('[DEBUG Frontend] Document item area clicked:', docPath);

                                                const doc = window.allFetchedDocuments ? window.allFetchedDocuments.find(d => d.path === docPath) : null;

                                                if (!doc || !doc.url) {
                                                    console.error('[DEBUG Frontend] Document data or URL not found for path:', docPath);
                                                    alert('ドキュメントの情報が見つからないため、開けませんでした。');
                                                    return;
                                                }

                                                const fullUrl = `${API_BASE_URL.replace('/api', '')}${doc.url}`;

                                                // Check for Chrome browser (specifically Google Chrome)
                                                const isChrome = navigator.userAgent.includes("Chrome") && navigator.vendor.includes("Google Inc");

                                                if (isChrome) {
                                                    console.log('[DEBUG Frontend] Chrome browser detected. Opening in new tab:', fullUrl);
                                                    window.open(fullUrl, '_blank');
                                                } else {
                                                    console.log('[DEBUG Frontend] Non-Chrome browser. Click on item does nothing. User should use download button.');
                                                    // For non-Chrome browsers, clicking the item itself does nothing.
                                                    // The user is expected to use the download button.
                                                    // The openDocumentViewer(docPath) call is removed for non-Chrome.
                                                }
                                            }
                                        }

                                        // NEW FUNCTION: Open the document viewer modal
                                        async function openDocumentViewer(docPath) {
                                            console.log('[DEBUG Frontend] openDocumentViewer called for path:', docPath);
                                             if (!documentViewerModal || !viewerTitle || !viewerContent || !downloadDocumentButton) {
                                                console.error("[DEBUG Frontend] Document viewer modal elements not found.");
                                                return;
                                            }

                                            viewerTitle.textContent = '読み込み中...';
                                            viewerContent.innerHTML = '<p class="text-center text-gray-500 py-10">コンテンツを読み込み中...</p>';
                                            downloadDocumentButton.classList.add('hidden'); // Hide download button initially

                                            documentViewerModal.classList.remove('hidden');
                                            document.body.classList.add('overflow-hidden'); // Prevent scrolling the background

                                            try {
                                                 // Find the document object in the loaded data using its path
                                                const doc = window.allFetchedDocuments.find(d => d.path === docPath);

                                                if (!doc) {
                                                     throw new Error("Document data not found locally.");
                                                }

                                                viewerTitle.textContent = doc.name || 'ドキュメント';
                                                // MODIFIED: Use the actual URL returned by the backend
                                                downloadDocumentButton.href = `${API_BASE_URL.replace('/api', '')}${doc.url}`; // Set download link directly from doc object
                                                downloadDocumentButton.setAttribute('download', doc.name || 'document'); // Suggest filename
                                                downloadDocumentButton.classList.remove('hidden'); // Show download button

                                                // Determine how to display based on type or URL extension
                                                const baseUrlForAssets = API_BASE_URL.replace('/api', ''); // http://127.0.0.1:5000

                                                if (doc.type === 'PDF' || doc.url.toLowerCase().endsWith('.pdf')) {
                                                    // Display PDF using iframe or PDF viewer
                                                    // Note: Serving local files via Flask needs care (e.g., using send_from_directory)
                                                    // Assuming doc.url is already a valid URL like /data/document/file.pdf
                                                    const pdfUrl = `${baseUrlForAssets}${doc.url}`; // Construct full URL
                                                    console.log('[DEBUG Frontend] Loading PDF:', pdfUrl);
                                                    // Use Google Docs Viewer for simplicity if direct iframe fails due to headers
                                                     viewerContent.innerHTML = `<iframe src="https://docs.google.com/viewer?url=${encodeURIComponent(pdfUrl)}&embedded=true" class="w-full h-full min-h-[calc(90vh - 8rem)]" style="border: none;"></iframe>`;
                                                    // Alternative: Direct iframe (might fail depending on server 'X-Frame-Options')
                                                    // viewerContent.innerHTML = `<iframe src="${pdfUrl}" class="w-full h-full min-h-[calc(90vh - 8rem)]" style="border: none;"></iframe>`;
                                                    viewerContent.classList.remove('prose'); // Remove prose styles for iframe
                                                } else if (doc.type === 'Markdown' || doc.url.toLowerCase().endsWith('.md')) {
                                                    // Fetch Markdown content and render it
                                                     console.log('[DEBUG Frontend] Fetching Markdown content:', doc.url);
                                                    // MODIFIED: Fetch markdown content from a dedicated backend endpoint, not direct file access
                                                    const mdContentResponse = await fetch(`${API_BASE_URL}/document/content?path=${encodeURIComponent(doc.path)}`);
                                                    if (!mdContentResponse.ok) throw new Error(`Failed to fetch Markdown content: ${mdContentResponse.status} ${mdContentResponse.statusText}`);
                                                     const mdContentData = await mdContentResponse.json(); // Assuming backend returns JSON with content
                                                    if (!mdContentData || !mdContentData.content) throw new Error(`Failed to get content from Markdown response.`);

                                                    const mdContent = mdContentData.content;

                                                     // Configure marked with context if needed (less likely for docs unless they have internal links)
                                                    // For simplicity, just render raw markdown
                                                    configureMarkedGlobally({ postTitle: null }); // Reset renderer options

                                                    const htmlContent = marked.parse(mdContent);
                                                    viewerContent.innerHTML = htmlContent;
                                                    viewerContent.classList.add('prose'); // Add prose styles for readability

                                                    // Apply syntax highlighting and KaTeX to rendered markdown
                                                    if (typeof hljs !== 'undefined') {
                                                        viewerContent.querySelectorAll('pre code').forEach(block => {
                                                            hljs.highlightElement(block);
                                                        });
                                                    }
                                                    if (typeof renderMathInElement === 'function') {
                                                        renderMathInElement(viewerContent, {
                                                             delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}],
                                                             throwOnError: false, errorColor: '#cc0000'
                                                        });
                                                    }


                                                } else if (doc.url) {
                                                    // For other file types, just show the download link or a message
                                                     console.log('[DEBUG Frontend] Document type not explicitly handled, showing download link.');
                                                    viewerContent.innerHTML = `<p class="text-center text-gray-600 py-10">このタイプのドキュメントは直接表示できませんが、ダウンロードできます。</p>`;
                                                    viewerContent.classList.remove('prose');
                                                } else {
                                                    throw new Error("Document URL is missing.");
                                                }

                                            } catch (error) {
                                                console.error('[DEBUG Frontend] ドキュメントビューアの表示に失敗しました:', error);
                                                viewerContent.innerHTML = `<p class="text-center text-red-500 py-10">ドキュメントの表示中にエラーが発生しました。<br>${error.message}</p>`;
                                                downloadDocumentButton.classList.add('hidden'); // Hide download on error
                                            }
                                        }

                                        // NEW FUNCTION: Close the document viewer modal
                                        function closeDocumentViewer() {
                                            if (documentViewerModal) {
                                                documentViewerModal.classList.add('hidden');
                                                document.body.classList.remove('overflow-hidden'); // Restore scrolling
                                                 // Stop video if it was a video file (unlikely for document section, but good practice)
                                                 const videoElement = documentViewerModal.querySelector('video');
                                                 if(videoElement) videoElement.pause();
                                                 // Clear the viewer content
                                                if (viewerContent) {
                                                    viewerContent.innerHTML = '';
                                                }
                                            }
                                        }

                                        // Add event listener for closing the document viewer modal
                                         if (closeViewerBtn) {
                                            closeViewerBtn.addEventListener('click', closeDocumentViewer);
                                        }

                                        // NEW: Add event listener to close modal when clicking outside the content
                                         if (documentViewerModal) { // {{ edit_1 }}
                                            documentViewerModal.addEventListener('click', function(event) { // {{ edit_2 }}
                                                // Check if the click target is the modal overlay itself, not content inside it
                                                if (event.target === documentViewerModal) { // {{ edit_3 }}
                                                    closeDocumentViewer(); // {{ edit_4 }}
                                                } // {{ edit_5 }}
                                            }); // {{ edit_6 }}
                                        } // {{ edit_7 }}


                                        // NEW FUNCTION: Apply filters and sort to loaded documents
                                        function applyDocumentFiltersAndSort() {
                                            console.log('[DEBUG Frontend] applyDocumentFiltersAndSort called.');
                                            if (!window.allFetchedDocuments) {
                                                console.warn('[DEBUG Frontend] No documents loaded yet.');
                                            }

                                            let documentsToProcess = [...window.allFetchedDocuments]; // Create a mutable copy

                                            // 1. Filtering
                                            const searchTerm = documentSearchInput ? documentSearchInput.value.toLowerCase() : '';
                                            const selectedType = documentTypeFilter ? documentTypeFilter.value : 'all';

                                            let filteredDocuments = documentsToProcess.filter(doc => {
                                                const matchesSearch = searchTerm === '' ||
                                                                    (doc.name && doc.name.toLowerCase().includes(searchTerm)) ||
                                                                    (doc.path && doc.path.toLowerCase().includes(searchTerm)) ||
                                                                    (doc.summary && doc.summary.toLowerCase().includes(searchTerm)); // Assuming doc might have a summary

                                                const matchesType = selectedType === 'all' ||
                                                                    (selectedType === 'PDF' && (doc.type === 'PDF' || (doc.name && doc.name.toLowerCase().endsWith('.pdf')))) ||
                                                                    (selectedType === 'Other' && doc.type !== 'PDF' && !(doc.name && doc.name.toLowerCase().endsWith('.pdf'))); // Assume 'Other' is anything not PDF

                                                return matchesSearch && matchesType;
                                            });

                                            console.log('[DEBUG Frontend] Documents after filtering:', filteredDocuments.length);

                                            // 2. Sorting
                                            const sortOrder = documentSortSelect ? documentSortSelect.value : 'name-asc';

                                            filteredDocuments.sort((a, b) => {
                                                const nameA = a.name ? String(a.name).toLowerCase() : '';
                                                const nameB = b.name ? String(b.name).toLowerCase() : '';
                                                const dateA = a.last_modified ? new Date(a.last_modified).getTime() : 0;
                                                const dateB = b.last_modified ? new Date(b.last_modified).getTime() : 0;

                                                if (sortOrder === 'name-asc') return nameA.localeCompare(nameB);
                                                if (sortOrder === 'name-desc') return nameB.localeCompare(nameA);
                                                if (sortOrder === 'date-desc') return dateB - dateA;
                                                if (sortOrder === 'date-asc') return dateA - dateB;
                                                return 0;
                                            });

                                            console.log('[DEBUG Frontend] Documents after sorting:', filteredDocuments.length);

                                            // 3. Render the filtered and sorted list
                                            renderDocumentList(filteredDocuments);
                                        }
                                    </script>

    <!-- Fixed Save Button for Editor -->
    <button id="fixed-editor-save-button" class="hidden fixed bottom-8 left-8 bg-black text-white w-14 h-14 rounded-full shadow-lg focus:outline-none hover:bg-gray-800 transition-colors z-[1050]">
        <svg class="mx-auto w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
        <!-- 使用 FontAwesome 图标替换 SVG -->
        <!-- <i class="fas fa-save text-2xl"></i> -->
    </button>

    </body>
</html>
                                        